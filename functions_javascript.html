<!DOCTYPE html><html lang="en">
<head>
<meta charset=UTF-8>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Learn about JavaScript functions, including different syntax options, how arguments work, and the behavior of functions in ECMAScript. Explore examples and understand the nuances of defining and using functions in JavaScript">
<meta name="keywords" content="JavaScript functions, function declaration, function expression, arrow functions, ECMAScript arguments, function behavior"><title>Understanding Functions in JavaScript: Syntax, Usage, and Examples</title><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
<script>MathJax = {
   tex: {
       inlineMath: [['$', '$'], ['\\(', '\\)']]
   },
   svg: {
       fontCache: 'global'
   }
};</script>
<script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script><script defer type="application/javascript" src="./resources/js/functions_javascript.js"></script><script defer src="./resources/js/donate.js"></script>
<link rel="stylesheet" href="./resources/css/basic.css" >
<link rel="stylesheet" href="./resources/css/functions_javascript.css" >
<script src="https://cdn.counter.dev/script.js" data-id="b0775af1-0d2d-4956-bf6a-2894dc0d0d57" data-utcoffset="3"></script>
</head>
<body>
<div class="container-fluid"><header class="py-3 border-bottom">
<div class="d-flex justify-content-between align-items-center">
<a href="/" class="text-decoration-none text-dark">
<span class="fw-bold fs-5">valex.github.io</span>
</a>
</div>
</header><section class="text-center py-5">
<h1 class="h4 d-flex justify-content-center align-items-center">Functions in JavaScript</h1>
</section><div class="row">
<div class="col-sm-8">
<p>In ECMAScript, functions are objects. Each function is an instance of the <code>Function</code> type, having properties and methods like other reference types. Since functions are considered objects, their names act as pointers to function objects and aren't strictly tied to the function itself.</p>
<p>Functions are commonly defined using the <i>function-declaration syntax</i>, as demonstrated in this example:</p><pre class="bg-light"><code>function add(a, b) {
    return a + b;
}
</code></pre><p>In this code, a variable <code>add</code> is defined and initialized to be a function. Notice that there's no semicolon (;) at the end. In JavaScript, when you define functions using this syntax, you don't need a semicolon after the closing brace.</p><br><br><p>To define a function, you can use the <i>function expression syntax</i>, which is almost a complete equivalent to the <i>function-declaration syntax</i>:</p><pre class="bg-light"><code>let add = function(a, b) {
    return a + b;
};
</code></pre><p>Note that there is a semicolon (;) after the end of the function.</p><br><br><p>Another way to define a function that is quite similar to a <i>function expression</i> is to use the "<i><b>arrow</b></i>" function syntax, like this:</p><pre class="bg-light"><code>let add = (a, b) => {
    return a + b;
};
</code></pre><br><br><p>To demonstrate that functions are objects and that the function name serves as a pointer to the object, there's another way to define a function:</p><pre class="bg-light"><code>// not recommended
let add = new Function("a", "b", "return a + b");
</code></pre><p>The <code>Function</code> constructor can take any number of arguments. The final argument is always treated as the function body, and the preceding arguments define the parameters for the new function.</p><div class="d-flex justify-content-between my-3">
<div class="toc">
<div class="toctitle">
<h4>Fast links</h4>
</div> 
<ul>
<li><a href="#arrow_functions"><span class="tocnumber">•</span> <span class="toctext">ARROW functions</span></a></li>
<li><a href="#function_names"><span class="tocnumber">•</span> <span class="toctext">Function names</span></a></li>
<li>
<a href="#arguments"><span class="tocnumber">•</span> <span class="toctext">Arguments</span></a> 
<ul>
<li><a href="#arguments_in_arrow"><span class="tocnumber">•</span> <span class="toctext">Arguments in Arrow Functions</span></a></li>
</ul>
</li> 
<li><a href="#default_parameter"><span class="tocnumber">•</span> <span class="toctext">Default Parameter Values</span></a></li>
<li><a href="#spread_arguments"><span class="tocnumber">•</span> <span class="toctext">Spread Arguments</span></a></li>
<li><a href="#rest_parameter"><span class="tocnumber">•</span> <span class="toctext">Rest Parameter</span></a></li>
<li><a href="#declaration_vs_expression"><span class="tocnumber">•</span> <span class="toctext">Differences Between Function Declarations and Function Expressions</span></a></li>
<li><a href="#functions_as_values"><span class="tocnumber">•</span> <span class="toctext">Functions as values</span></a></li>
<li>
<a href="#function_inside"><span class="tocnumber">•</span> <span class="toctext">Inside a function</span></a> 
<ul>
<li><a href="#function_inside_arguments"><span class="tocnumber">•</span> <span class="toctext">arguments</span></a></li>
<li><a href="#function_inside_this"><span class="tocnumber">•</span> <span class="toctext">this</span></a></li>
<li><a href="#function_inside_caller"><span class="tocnumber">•</span> <span class="toctext">caller</span></a></li>
<li><a href="#function_inside_new_target"><span class="tocnumber">•</span> <span class="toctext">new.target</span></a></li>
</ul>
</li> 
<li>
<a href="#props_methods"><span class="tocnumber">•</span> <span class="toctext">Properties and methods</span></a> 
<ul>
<li><a href="#method_apply"><span class="tocnumber">•</span> <span class="toctext">apply()</span></a></li>
<li><a href="#method_call"><span class="tocnumber">•</span> <span class="toctext">call()</span></a></li>
<li><a href="#method_bind"><span class="tocnumber">•</span> <span class="toctext">bind()</span></a></li>
</ul>
</li> 
<li><a href="#function_expressions"><span class="tocnumber">•</span> <span class="toctext">Function expressions</span></a></li>
<li>
<a href="#closures"><span class="tocnumber">•</span> <span class="toctext">Closures</span></a> 
<ul>
<li><a href="#this_in_closures"><span class="tocnumber">•</span> <span class="toctext">this in closures</span></a></li>
<li>
<a href="#memory_leaks"><span class="tocnumber">•</span> <span class="toctext">Memory Leaks</span></a>
<ul>
<li><a href="#managing_memory_with_closures"><span class="tocnumber">•</span> <span class="toctext">Managing Memory with Closures</span></a></li>
</ul>
</li>
</ul>
</li> 
<li><a href="#iife"><span class="tocnumber">•</span> <span class="toctext">Immediately Invoked Function Expressions</span></a></li>
<li><a href="#private_variables"><span class="tocnumber">•</span> <span class="toctext">Private Variables and Functions</span></a></li>
</ul>
</div>
</div><br><br><h2 id="arrow_functions">ARROW functions</h2><p>In ECMAScript 6, there's a new way to create function expressions using the fat-arrow syntax. Arrow functions mostly work the same as regular function expressions. You can use arrow functions anywhere you'd use a regular function expression:</p><pre class="bg-light"><code>let arrowMultiply = (x, y) => {
    return x * y;
};

let functionExpressionMultiply = function(x, y) {
    return x * y;
};

console.log(arrowMultiply(3, 4)); // 12
console.log(functionExpressionMultiply(3, 4)); // 12
</code></pre><br><br><p>Arrow functions are really handy when you want to write short and simple code, especially in inline situations:</p><pre class="bg-light"><code>let numbers = [1, 2, 3];

console.log(numbers.map(function(number) { return number * 2; })); // [2, 4, 6]
console.log(numbers.map((number) => { return number * 2 })); // [2, 4, 6]
</code></pre><br><br><p>Arrow functions don't need parentheses if you have just one parameter. But if you have zero or more than one parameter, you need to use parentheses:</p><pre class="bg-light"><code>// Both are valid
let doubleValue = (x) => { return 2 * x; };
let tripleValue = x => { return 3 * x; };

// Zero parameters require an empty pair of parentheses
let getRandomNumber = () => { return Math.random(); };

// Multiple parameters require parentheses
let calculateSum = (a, b) => { return a + b; };

// Invalid syntax:
let invalidMultiply = a, b => { return a * b; };
</code></pre><br><br><p>Arrow functions don't necessarily require curly braces, but choosing not to use them alters the behavior of the function. When you use curly braces, it's called "block body" syntax, and it works like a regular function expression. You can have multiple lines of code inside. If you skip the curly braces, it's the "concise body" syntax, and you're limited to just one line of code, like an assignment or expression. The value of this line will automatically be returned:</p><pre class="bg-light"><code>// Both are valid and will return the value
let doubleValue = (x) => { return 2 * x; };
let tripleValue = (x) => 3 * x;

// Assignment is allowed
let value = {};
let setName = (x) => x.name = "Karl";
setName(value);
console.log(value.name); // "Karl"

// Invalid syntax:
let invalidMultiply = (a, b) => return a * b;
</code></pre><br><br><p>While arrow functions are concise in syntax, they're not suitable for several situations. They don't support the use of <code>arguments</code>, <code>super</code>, or <code>new.target</code>, and they can't be used as constructors. Moreover, function objects created with the arrow syntax lack a defined <code>prototype</code> property.</p><br><br><h2 id="function_names">Function names</h2><p>Since function names are basically pointers to functions, they behave like any other variable holding a pointer to an object. This allows having multiple names for a single function. For instance:</p><pre class="bg-light"><code>function sum(a, b) {
    return a + b;
}

console.log(sum(5, 10)); // 15

let anotherSum = sum;
console.log(anotherSum(5, 10)); // 15

sum = null;
console.log(anotherSum(5, 10)); // 15
</code></pre><p>This code creates a function called <code>sum()</code> that adds two numbers. A variable, <code>anotherSum</code>, is declared and assigned the value of <code>sum</code>. When we use the function name without parentheses, it refers to the function itself rather than executing it. At this stage, both <code>anotherSum</code> and <code>sum</code> point to the same function, so calling <code>anotherSum()</code> returns a result. When <code>sum</code> is set to <code>null</code>, it breaks its connection with the function. However, calling <code>anotherSum()</code> still works without any issues.</p><br><br><h2 id="arguments">Arguments</h2><p>In ECMAScript, function arguments work differently compared to many other programming languages. When you define a function in ECMAScript, it doesn't care how many arguments you pass to it or what data types those arguments are. Even if you specify a function to take two arguments, you can actually pass in any number of arguments, including one, three, or none, without causing an issue for the interpreter.</p><p>This flexibility exists because in ECMAScript, arguments are internally represented <i>as an array</i>. This array is always sent to the function, but the function doesn't pay attention to the contents of the array. Whether the array is empty or has multiple items, the function will still work. When you define a function using the <code>function</code> keyword (not an arrow function), there is an <code>arguments</code> object available within the function. This <code>arguments</code> object behaves like an array, allowing you to access each argument using bracket notation (<code>arguments[0]</code> for the first argument, <code>arguments[1]</code> for the second, and so on) and determine the number of arguments passed in using the <code>length</code> property.</p><p>In the following example, the <code>sayHello()</code> function’s first argument is named <code>name</code>:</p><pre class="bg-light"><code>function sayHello(name, message) {
    console.log("Hello " + name + ", " + message);
}
</code></pre><br><br><p>You can access the same value by using <code>arguments[0]</code>. This allows you to rewrite the function without explicitly naming the arguments, like this:</p><pre class="bg-light"><code>function sayHello() {
    console.log("Hello " + arguments[0] + ", " + arguments[1]);
}
</code></pre><p>In this rewritten version, the specific names for the arguments have been taken out. Even without the names "<code>name</code>" and "<code>message</code>", the function will still work correctly. This shows that in ECMAScript, having named arguments is helpful but <i>not mandatory</i>.</p><br><br><p>You can also use the <code>arguments</code> object to count the number of arguments passed into the function using the <code>length</code> property. The next example shows how many arguments are passed into the function every time it is called:</p><pre class="bg-light"><code>function countArgs() {
    console.log(arguments.length);
}

countArgs("apple", "banana", "orange"); // 3
countArgs(1, 2, 3, 4, 5); // 5
countArgs(true, false); // 2
</code></pre><br><br><p>If you don't pass a value for a <i>named argument</i> into a function, it will automatically be set as <code>undefined</code>. This is similar to creating a variable without giving it a value.</p><br><br><h3 id="arguments_in_arrow">Arguments in Arrow Functions</h3><p>When you use the <i>arrow function</i> notation to define a function, you can't access the passed arguments using the <code>arguments</code> keyword; you can only access them by their specific names in the function definition.</p><p>For example:</p><pre class="bg-light"><code>function printNumber() {
    console.log(arguments[0]);
}
printNumber(10); // Output: 10


let printValue = () => {
    console.log(arguments[0]);
};
printValue(10); // Output: ReferenceError: arguments is not defined</code></pre><br><br><p>Even though the <code>arguments</code> keyword may not work in arrow functions, it's possible for the <code>arguments</code> to be accessible if they are provided from the scope of a surrounding function being called:</p><p>For example:</p><pre class="bg-light"><code>function printNumber() {
    let printValue = () => {
        console.log(arguments[0]);
    };
    printValue();
}

printNumber(10); // Output: 10</code></pre><br><br><h2 id="default_parameter">Default Parameter Values</h2><p>In older versions of ECMAScript before 5.1, a popular way to set default parameter values was to check if a parameter was missing in the function call by verifying if it was <code>undefined</code>, and then assigning a value to the parameter if it was indeed undefined. For example:</p><pre class="bg-light"><code>function greetUser(userName) {
    userName = (typeof userName !== 'undefined') ? userName : 'Guest';
    return `Hello, ${userName}!`;
}
console.log(greetUser()); // 'Hello, Guest!'
console.log(greetUser('Alice')); // 'Hello, Alice!'</code></pre><br><br><p>In ECMAScript 6, there is no longer a need for the previous workaround, as it allows for defining default parameter values directly in the function signature using the <code>=</code> operator. The equivalent of the previous function using ES6 default parameters would be:</p><pre class="bg-light"><code>function greetUser(userName = 'Guest') {
    return `Hello, ${userName}!`;
}
console.log(greetUser()); // 'Hello, Guest!'
console.log(greetUser('Alice')); // 'Hello, Alice!'
</code></pre><br><br><p>When you pass <code>undefined</code> as an argument, it is handled similarly to not passing any argument at all. This feature enables the use of multiple independent default variables. Here's an example using ES6 default parameters:</p><pre class="bg-light"><code>function createCharacter(characterName = 'Alice', role = 'Explorer') {
    return `${characterName} the ${role}`;
}
console.log(createCharacter()); // 'Alice the Explorer'
console.log(createCharacter('Bob')); // 'Bob the Explorer'
console.log(createCharacter(undefined, 'Wizard')); // 'Alice the Wizard'
</code></pre><br><br><p>When using default parameters, the <code>arguments</code> object's value does not show the default value of a parameter, but rather the actual argument passed to the function. This aligns with the behavior in ES5 strict mode and is beneficial because it maintains the values as they were passed during the function invocation:</p><pre class="bg-light"><code>function greetUser(userName = 'Guest') {
    return `Hello, ${arguments[0]}!`;
}
console.log(greetUser()); // 'Hello, undefined!'
console.log(greetUser('Alice')); // 'Hello, Alice!'
</code></pre><br><br><p>You can set default parameter values to be <i>the result of a function call</i>, not just fixed values or objects:</p><pre class="bg-light"><code>let colors = ['Red', 'Blue', 'Green'];
let index = 0;

function getNextColor() {
    return colors[index++ % colors.length];
}

function paintHouse(houseNumber, color = getNextColor()) {
    return `House ${houseNumber} is painted ${color}`;
}

console.log(paintHouse(1)); // House 1 is painted Red
console.log(paintHouse(2, 'Yellow')); // House 2 is painted Yellow
console.log(paintHouse(3)); // House 3 is painted Blue
console.log(paintHouse(4)); // House 4 is painted Green
</code></pre><p>The default parameter value is calculated only <b><i>when the function is called</i></b>, not when it's defined. The calculation for the default value only happens if the argument is missing.</p><br><br><p>Arrow functions can also use default parameters similarly, but if a default value is set, parentheses around a single argument become mandatory:</p><pre class="bg-light"><code>let greetUser = (userName = 'Guest') => `Hello, ${userName}!`;
console.log(greetUser()); // Hello, Guest!
</code></pre><br><br><h2 id="spread_arguments">Spread Arguments</h2><p>Instead of passing an array as one argument to a function, it's often helpful to split the array into individual values and pass each value separately.</p><p>For example, if you have a function like this that sums all the values passed as arguments:</p><pre class="bg-light"><code>let values = [1, 2, 3, 4];

function getSum() {
    let sum = 0;
    for (let i = 0; i < arguments.length; ++i) {
        sum += arguments[i];
    }
    return sum;
}
</code></pre><p>This function expects each argument to be a single number that will be added together to find the sum. To pass an array of values to this function, you can use the <code>.apply()</code> method to flatten the array into separate parameters:</p><pre class="bg-light"><code>console.log(getSum.apply(null, values)); // Output: 10
</code></pre><p>In ECMAScript 6, you can now do this more simply using the <i>spread operator (...)</i>. When you apply the spread operator to an iterable object and pass it as a single argument to a function, it breaks down the object into individual arguments. This allows you to unpack an array directly into separate arguments within the function call. For example:</p><pre class="bg-light"><code>console.log(getSum(...values)); // 10
</code></pre><br><br><p>Since the array size is known, you can freely place other parameters <i>before or after</i> the spread operator, including additional spread operators:</p><pre class="bg-light"><code>console.log(getSum(-1, ...values)); // Output: 9
console.log(getSum(...values, 5)); // Output: 15
console.log(getSum(-1, ...values, 5)); // Output: 14
console.log(getSum(...values, ...[5, 6, 7])); // Output: 28
</code></pre><p>In these examples, you can see how you can mix the spread operator with other parameters to pass values efficiently to the function.</p><br><br><p>The spread operator is not recognized by the <code>arguments</code> object; it treats the spread values as individual pieces because that's how they are passed to the function:</p><pre class="bg-light"><code>let values = [1, 2, 3, 4];

function countArguments() {
    console.log(arguments.length);
}

countArguments(-1, ...values); // Output: 5
countArguments(...values, 5); // Output: 5
countArguments(-1, ...values, 5); // Output: 6
countArguments(...values, ...[5, 6, 7]); // Output: 7

</code></pre><br><br><h2 id="rest_parameter">Rest Parameter</h2><p>When defining a function, you can use the spread operator to combine variable-length parameters into a single array. This is similar to how the <code>arguments</code> object works, but with the spread operator, the parameters become part of a formal <code>Array</code> object:</p><pre class="bg-light"><code>function getTotal(...numbers) {
    return numbers.reduce((sum, num) => sum + num, 0);
}

console.log(getTotal(1, 2, 3)); // Output: 6
</code></pre><br><br><p>If there are named parameters before the rest parameter, the rest parameter will capture the remaining unnamed parameters as an array, or it will be an empty array if there are no remaining parameters. The rest parameter must always be the last formal parameter because it can vary in size.</p><p>Here's a simple example to illustrate this concept:</p><pre class="bg-light"><code>function printValues(first, second, ...rest) {
    console.log("First:", first);
    console.log("Second:", second);
    console.log("Rest:", rest);
}

printValues(1, 2, 3, 4, 5);
// Output:
// First: 1
// Second: 2
// Rest: [3, 4, 5]
</code></pre><br><br><p>While arrow functions do not support the <code>arguments</code> object, they do support <i>rest parameters</i>, providing functionality that closely resembles <code>arguments</code>:</p><pre class="bg-light"><code>const sumValues = (...args) => {
    return args.reduce((total, num) => total + num, 0);
};

console.log(sumValues(1, 2, 3, 4)); // Output: 10

</code></pre><br><br><p>As expected, using a <i>rest parameter</i> does not impact the <code>arguments</code> object — it will continue to reflect exactly what was passed to the function:</p><pre class="bg-light"><code>function exampleFunction(...args) {
    console.log("Rest Parameter:", args);
    console.log("Arguments Object:", arguments);
}

exampleFunction(1, 2, 3);

// Output:
// Rest Parameter: Array(3) [ 1, 2, 3 ]
// Arguments Object:Arguments { 0: 1, 1: 2, 2: 3, … }

</code></pre><br><br><h2 id="declaration_vs_expression">Differences Between Function Declarations and Function Expressions</h2><p><i>Function declarations</i> and <i>function expressions</i> are similar in many ways, but there is a crucial difference in how JavaScript engines handle them. <i>Function declarations</i> are loaded and available in the execution context before any code is executed, thanks to a process called <b><i>function declaration hoisting</i></b>. On the other hand, <i>function expressions</i> are not fully defined until the code execution reaches that line.</p><p>For example:</p><pre class="bg-light"><code>// Function Declaration - OK
console.log(multiplyNumbers(3, 5));
function multiplyNumbers(a, b) {
    return a * b;
}

// Function Expression - Error
console.log(multiplyNumbers(3, 5));
let multiplyNumbers = function(a, b) {
    return a * b;
};
</code></pre><p>In the first case, the <i>function declaration</i> works fine due to <b><i>hoisting</i></b>, while in the second case, using a <i>function expression</i> causes an error because the function isn't available until the line where it's defined is executed. This issue occurs regardless of using <code>let</code> or <code>var</code>.</p><p>Apart from this availability difference, <i>function declarations</i> and <i>function expressions</i> are essentially equivalent in functionality.</p><br><br><h2 id="functions_as_values">Functions as values</h2><p>In ECMAScript, functions are like <i>variables</i>, so you can use them just like you would use variables. This allows you to pass a function <i>as an argument</i> to another function and even return a function as the result of another function. Consider the following function:</p><pre class="bg-light"><code>function applyOperation(operation, number) {
    return operation(number);
}
</code></pre><p>This function takes two arguments. The first argument should be a function, and the second argument should be a value to pass to that function. You can pass any function in this way:</p><pre class="bg-light"><code>function squareNumber(x) {
    return x * x;
}

let result1 = applyOperation(squareNumber, 5);
console.log(result1); // Output: 25

function greetPerson(personName) {
    return "Hello, " + personName;
}

let result2 = applyOperation(greetPerson, "Alice");
console.log(result2); // Output: "Hello, Alice"
</code></pre><p>The <code>applyOperation()</code> function is generic, meaning it doesn't matter which function is passed as the first argument — the result will always come from executing the first argument. To pass a <i>function pointer</i> instead of executing the function, you should omit the parentheses. This way, the variables <code>squareNumber</code> and <code>greetPerson</code> are passed into <code>applyOperation()</code> without executing them.</p><br><br><p>Returning a function from a function is a useful capability. For example, if you have an array of objects and need to sort it based on a specific object property, you can create a comparison function dynamically. The <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort()</a></code> method of an array requires a comparison function that compares two values, but you may need to specify <i>which property to sort by</i>. This can be solved by creating a function that generates a comparison function based on a property name, as in the following example:</p><pre class="bg-light"><code>function createSortingFunction(property) {
    return function(obj1, obj2) {
        let value1 = obj1[property];
        let value2 = obj2[property];
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
</code></pre><p>The syntax of this function may seem complex, but it's simply a function inside of a function, with the outer function returning the inner function. The <code>property</code> argument is accessible within the inner function and is used with bracket notation to access the property values for comparison. Once the <code>property</code> values are obtained, a straightforward comparison can be performed.</p><p>Here's an example of how this function can be used:</p><pre class="bg-light"><code>let people = [
    {name: "Emma", age: 28},
    {name: "David", age: 29}
];

people.sort(createSortingFunction("name"));
console.log(people[0].name); // Output: David

people.sort(createSortingFunction("age"));
console.log(people[0].name); // Output: Emma
</code></pre><p>In this code, an array named <code>people</code> is defined with two objects, each containing a <code>name</code> and an <code>age</code> property. By default, the <code>sort()</code> method would use <code>toString()</code> to sort the objects, which might not provide the desired order.</p><p>When <code>createSortingFunction("name")</code> is invoked, it generates a comparison function that sorts the objects based on the <code>name</code> property. Consequently, the first item in the sorted array will have the name "David".</p><p>On the other hand, calling <code>createSortingFunction("age")</code> creates a comparison function that sorts the objects based on the <code>age</code> property. This results in the first item being the one with the name "Emma" and an age of 28.</p><br><br><h2 id="function_inside">Inside a function</h2><p>Inside a function in JavaScript, there are several special objects that provide additional context and functionality within a function, allowing you to access arguments, refer to the function itself, and determine the calling context.</p><br><br><h3 id="function_inside_arguments">arguments</h3><p>The <code>arguments</code> object is <i>like an array</i> that holds all the values passed into a function (<a href="#arguments">Learn more</a>). It's there when you define a function using the <code>function</code> keyword (not with arrow functions). Besides storing the function's arguments, it also has a property called <code>callee</code> <small>(<code>arguments.callee</code> property is deprecated in modern JavaScript and should be avoided)</small>, which points back to the function itself. Let's look at a typical factorial function as an example:</p><pre class="bg-light"><code>function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
}
</code></pre><p>Factorial functions are usually recursive, like in this example. It works well when the function name is fixed as "<code>factorial</code>". However, the function's proper execution is closely tied to this specific name. To make it more flexible, you can use <code>arguments.callee</code> to decouple it from the function name:</p><pre class="bg-light"><code>function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
</code></pre><p>In this updated version of the <code>factorial()</code> function, the function no longer directly references its own name "<code>factorial</code>" within the function body. This change guarantees that the recursive call will always be made to the correct function, regardless of how the function is named or referenced.</p><br><br><p>In strict mode, the value of <code>arguments.callee</code> is not accessible and attempting to read it will result in an error. To overcome this limitation, you can utilize <i>named function expressions</i> to achieve the same result. Here is an example:</p><pre class="bg-light"><code>const factorial = (function f(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num - 1);
    }
});
</code></pre><p>In this code, a named function expression <code>f()</code> is created and assigned to the variable <code>factorial</code>. The name <code>f</code> remains the same even if the function is assigned to another variable, so the recursive call will always execute correctly. This pattern works in both nonstrict mode and strict mode.</p><br><br><h3 id="function_inside_this">this</h3><p>In JavaScript, the special object <code>this</code> works differently in standard functions and arrow functions.</p><p>In a standard function, <code>this</code> refers to the object the function is working with. When used globally, <code>this</code> points to the <code>window</code> object. Consider the following:</p><pre class="bg-light"><code>window.brand = 'Toyota';

let car = {
    brand: 'Ford'
};

function displayBrand() {
    console.log(this.brand);
}

displayBrand(); // 'Toyota'

car.displayBrand = displayBrand;
car.displayBrand(); // 'Ford'
</code></pre><p>When the function <code>displayBrand()</code> is called globally, it outputs <code>"Toyota"</code> because <code>this</code> points to the <code>window</code> object, and <code>this.brand</code> evaluates to <code>window.brand</code>. Once the <code>displayBrand()</code> function is assigned to the <code>car</code> object and called through <code>car.displayBrand()</code>, <code>this</code> now refers to the <code>car</code> object, and <code>this.brand</code> evaluates to <code>car.brand</code>, resulting in the output <code>"Ford"</code>.</p><br><br><p>Inside an arrow function, <code>this</code> refers to the context in which the arrow function expression is defined. This concept is illustrated in the following example, where two separate invocations of <code>displayBrand</code> both access the property of the <code>window</code> object, which represents the context where the arrow function was originally defined.</p><pre class="bg-light"><code>window.brand = 'Toyota';

let car = {
    brand: 'Ford'
};

let displayBrand = () => console.log(this.brand);


displayBrand(); // 'Toyota'

car.displayBrand = displayBrand;
car.displayBrand(); // 'Toyota'
</code></pre><br><br><p>This is especially useful in situations where events or timeouts will invoke a function inside a callback where the invoking object is not the intended object. When an arrow function is used in these situations, the context referenced by <code>this</code> is preserved:</p><pre class="bg-light"><code>function Emperor() {
    this.royaltyName = 'Julius';
    // 'this' will refer to the Emperor instance
    setTimeout(() => console.log(this.royaltyName), 1000);
}

function Empress() {
    this.royaltyName = 'Cleopatra';
    // 'this' will refer to the window object
    setTimeout(function() { console.log(this.royaltyName); }, 1000);
}

new Emperor(); // Output: 'Julius'
new Empress(); // Output: 'undefined'
</code></pre><br><br><h3 id="function_inside_caller">caller</h3><p>The <code>caller</code> property holds a reference to the function that invoked the current function, or it is <code>null</code> if the function was called from the global scope:</p><pre class="bg-light"><code>function outer() {
    inner();
}

function inner() {
    console.log(inner.caller);
}
outer(); //  will display the source text of the outer() function
</code></pre><p>This code displays an alert with the source text of the <code>outer()</code> function. This is because <code>outer()</code> calls <code>inner()</code>, and <code>inner.caller</code> refers back to <code>outer()</code>.</p><br><br><h3 id="function_inside_new_target">new.target</h3><p>In JavaScript, functions can act as constructors to create new objects or as regular callable functions. A new feature introduced in ECMAScript 6 is the <code>new.target</code> property, which allows you to determine if a function was invoked with the <code>new</code> keyword.</p><p>If a function is called normally, <code>new.target</code> will be <code>undefined</code>. However, if a function is called using the <code>new</code> keyword, <code>new.target</code> will reference the constructor or function itself.</p><p>This feature provides a way to differentiate between regular function calls and constructor calls in JavaScript:</p><pre class="bg-light"><code>function Emperor() {
    if ( ! new.target) {
        throw 'Emperor must be instantiated using "new"';
    }
    console.log('Emperor instantiated using "new"');
}

new Emperor(); // Output: Emperor instantiated using "new"
// Emperor(); // Throws an error: Emperor must be instantiated using "new"
</code></pre><br><br><h2 id="props_methods">Properties and methods</h2><p>In ECMAScript, functions are treated <i>as objects</i>, which means they have <b>properties</b> and <b>methods</b>. Every function in JavaScript has two key properties: <code>length</code> and <code>prototype</code>. The <code>length</code> property specifies the number of named arguments that the function expects, as illustrated in the following example:</p><pre class="bg-light"><code>function greetUser(user) {
    console.log("Hello, " + user);
}

function calculateTotal(price, quantity) {
    return price * quantity;
}

function sayHello() {
    console.log("Hello there!");
}

console.log(greetUser.length); // Output: 1
console.log(calculateTotal.length); // Output: 2
console.log(sayHello.length); // Output: 0
</code></pre><p>In this code snippet, there are three functions defined, each with a different number of named arguments. The <code>greetUser()</code> function expects one argument, so its <code>length</code> property is set to 1. Similarly, the <code>calculateTotal()</code> function requires two arguments, resulting in a <code>length</code> property of 2. Lastly, the <code>sayHello()</code> function does not have any named arguments, leading to a <code>length</code> property value of 0.</p><br><br><p>The <code>prototype</code> property is a crucial aspect of the ECMAScript core. It serves as the actual storage location for all instance methods of reference types. This means that methods like <code>toString()</code> and <code>valueOf()</code> are stored on the <code>prototype</code> and accessed from object instances. The <code>prototype</code> property plays a significant role in defining custom reference types and implementing inheritance. In ECMAScript 5, the <code>prototype</code> property is non-enumerable, which means it won't be discovered using a <code>for-in</code> loop.</p><br><br><h3 id="method_apply">apply()</h3><p>In JavaScript, functions have two useful methods: <code>apply()</code> and <code>call()</code>. These methods allow you to call a function while specifying a particular <code>this</code> value, essentially setting the context within the function.</p><p>The <code>apply()</code> method takes two arguments: the value of this inside the function and an array of arguments. The second argument can be an array or the <code>arguments</code> object itself. Consider the following:</p><pre class="bg-light"><code>function multiply(num1, num2) {
    return num1 * num2;
}

function callMultiply1(num1, num2) {
    return multiply.apply(this, arguments);
}

function callMultiply2(num1, num2) {
    return multiply.apply(this, [num1, num2]);
}

console.log(callMultiply1(5, 5)); // Output: 25
console.log(callMultiply2(5, 5)); // Output: 25

</code></pre><p>In this example, <code>callMultiply1()</code> call the <code>multiply()</code> function, passing in <code>this</code> as the <code>this</code> value (which is equal to <code>window</code> because it’s being called in the global scope) and also passing in the <code>arguments</code> object. The <code>callMultiply2()</code> method also calls <code>multiply()</code>, but it passes in an array of the arguments instead. Both functions will execute and return the correct result.</p><br><br><h3 id="method_call">call()</h3><p>The <code>call()</code> method functions similarly to <code>apply()</code>, but the way arguments are passed differs. In <code>call()</code>, the first argument is the <code>this</code> value, while the subsequent arguments are passed directly into the function. When using <code>call()</code>, arguments need to be explicitly listed, as shown in this example:</p><pre class="bg-light"><code>function multiply(num1, num2) {
    return num1 * num2;
}

function callMultiply(num1, num2) {
    return multiply.call(this, num1, num2);
}

console.log(callMultiply(5, 5)); // Output: 25
</code></pre><p>The <code>callMultiply()</code> method needs to explicitly list each of its arguments when using the <code>call()</code> method. The result is equivalent to using <code>apply()</code>. The choice between <code>apply()</code> and <code>call()</code> depends on the most convenient way for passing arguments into the function. If you plan to pass the <code>arguments</code> object directly or already have an array of data to pass in, then <code>apply()</code> is the preferred option. Otherwise, <code>call()</code> might be more suitable. If there are no arguments to pass in, these methods behave identically.</p><br><br><p>The real strength of <code>apply()</code> and <code>call()</code> lies in their capability to modify the <code>this</code> value within the function. Let's explore this concept with the following example:</p><pre class="bg-light"><code>window.brand = 'Toyota';

let car = {
    brand: 'Ford'
};

function displayBrand() {
    console.log(this.brand);
}

displayBrand(); // 'Toyota'

displayBrand.call(this); // 'Toyota'
displayBrand.call(window); // 'Toyota'
displayBrand.call(car);  // 'Ford'
</code></pre><p>In this example <code>displayBrand()</code> is defined as a global function, and when it’s called in the global scope, it displays "<code>Toyota</code>" because <code>this.brand</code> evaluates to <code>window.brand</code>. You can then call the function explicitly in the global scope by using <code>displayBrand.call(this)</code> and <code>displayBrand.call(window)</code>, which both display "<code>Toyota</code>". Running <code>displayBrand.call(car)</code> switches the context of the function such that <code>this</code> points to <code>car</code>, resulting in a display of "<code>Ford</code>".</p><br><br><h3 id="method_bind">bind()</h3><p>ECMAScript 5 introduces a new method called <code>bind()</code>. The <code>bind()</code> method generates a new function instance where the <code>this</code> value is bound to the value provided to <code>bind()</code>. Here is an example:</p><pre class="bg-light"><code>window.brand = 'Toyota';

let car = {
    brand: 'Ford'
};

function displayBrand() {
    console.log(this.brand);
}

let boundDisplayBrand = displayBrand.bind(car);
boundDisplayBrand(); // 'Ford'
</code></pre><p>Here, a new function called <code>boundDisplayBrand()</code> is created from <code>displayBrand()</code> by calling <code>bind()</code> and passing in the object <code>car</code>. The <code>boundDisplayBrand()</code> function has a <code>this</code> value equivalent to <code>car</code>, so calling the function, even as a global call, results in the string "<code>Ford</code>" being displayed.</p><br><br><h2 id="function_expressions">Function expressions</h2><p>One of the more powerful, and often confusing, parts of JavaScript is <i>function expressions</i>. There are two primary ways to define a function: through <i>function declaration</i> and <i>function expression</i>. Function declaration takes the form:</p><pre class="bg-light"><code>function functionName(arg0, arg1, arg2) {
    // function body
}
</code></pre><p>One of the key characteristics of function declarations is <b><i>function declaration hoisting</i></b>, a behavior where function declarations are read before the code executes. This allows a function declaration to be placed after the code that calls it and still function correctly:</p><pre class="bg-light"><code>sayHello();
function sayHello() {
    console.log("Hello!");
}
</code></pre><p>This example doesn’t throw an error because of <i>function declaration hoisting</i>. The function declaration is processed first before the code execution begins, allowing the function to be called successfully even though it appears after the call in the code.</p><br><br><p>Another method to create a function in JavaScript is through a <i>function expression</i>. Function expressions come in various forms, with the most common being:</p><pre class="bg-light"><code>let functionName = function(arg0, arg1, arg2) {
    // function body
};
</code></pre><p>This pattern of function expression looks like a normal variable assignment. A function is created and assigned to the variable <code>functionName</code>. The created function is considered to be an <i>anonymous function</i>, because it has no identifier after the <code>function</code> keyword. (Anonymous functions are also sometimes called <i>lambda functions</i>.) This means the <code>name</code> property is the empty string.</p><p>Function expressions behave like other expressions in JavaScript and must be assigned before they are used:</p><pre class="bg-light"><code>sayHello(); // Error! function doesn't exist yet
function sayHello() {
    console.log("Hello!");
}</code></pre><br><br><p>Understanding <i>function hoisting</i> is key to understanding the differences between function declarations and function expressions. For instance, the result of the following code may be surprising:</p><pre class="bg-light"><code>// Never do this!
if (condition) {
    function greet() {
        greeting = 'Hello!';
    }
} else {
    function greet() {
        greeting = 'Hi!';
    }
}
</code></pre><p>The code appears to suggest using one definition for <code>greet()</code> if a <code>condition</code> is <code>true</code>, and another definition if <code>false</code>. However, this is not valid syntax in ECMAScript. JavaScript engines attempt to error-correct, but browsers may not consistently handle this situation. Most browsers return the second declaration regardless of the condition, while Firefox returns the first if the condition is <code>true</code>. This approach is unreliable and should be avoided. Instead, it is acceptable to use <i>function expressions</i> in a conditional manner:</p><pre class="bg-light"><code>// OK
let greet;
if (condition) {
    greet = function() {
        console.log("Hello!");
    };
} else {
    greet = function() {
        console.log("Hi!");
    };
}
</code></pre><p>This example behaves the way you would expect, assigning the correct function expression to the variable <code>greet</code> based on condition.</p><br><br><p>The ability to create functions for assignment to variables also allows you to return functions as the value of other functions:</p><pre class="bg-light"><code>function createSortingFunction(property) {
    return function(obj1, obj2) {
        let value1 = obj1[property];
        let value2 = obj2[property];
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
</code></pre><p><code>createSortingFunction()</code> returns an anonymous function. The returned function will, presumably, be either assigned to a variable or otherwise called, but within <code>createSortingFunction()</code> it is anonymous. Any time a function is being used as a value, it is a <i>function expression</i>.</p><br><br><h2 id="closures">Closures</h2><p>A <b>closure</b> in JavaScript is a function that has access to variables from an <i>outer scope</i>, even after the outer function has finished executing. Closures allow functions to retain access to variables from their parent scope even after the parent function has completed its execution.</p><p>Here is an example of a closure in JavaScript:</p><pre class="bg-light"><code>function outerFunction() {
    let outerVariable = 'I am from the outer function';

    function innerFunction() {
        console.log(outerVariable); // The inner function has access to outerVariable from the outer function
    }

    return innerFunction;
}

let closureExample = outerFunction();
closureExample(); // Outputs: "I am from the outer function"
</code></pre><p>In this example, <code>innerFunction</code> is a closure because it retains access to the variable <code>outerVariable</code> from the outer function <code>outerFunction</code>, even after <code>outerFunction</code> has finished executing.</p><br><br><h3 id="this_in_closures">this in closures</h3><p>Using <code>this</code> in JavaScript closures can be challenging due to the dynamic nature of <code>this</code>. Unlike variables, which are lexically scoped, <code>this</code> is determined at runtime based on the context <i>in which a function is called</i>. This dynamic binding means that the value of <code>this</code> can change depending on how a function is invoked, leading to potential confusion when using <code>this</code> inside closures.</p><p>One common issue arises when <code>this</code> inside a closure does not refer to the expected object. Instead, it can refer to the global object (in non-strict mode) or be <code>undefined</code> (in strict mode). To address this, developers have devised several strategies.</p><p>One popular approach is to save the value of <code>this</code> in a variable before entering the closure. This variable, often named <code>self</code> or <code>that</code>, ensures the correct reference is maintained. For instance, consider the following example:</p><pre class="bg-light"><code>function outerFunction() {
    let self = this; // Save the context

    function innerFunction() {
        console.log(self); // Use the saved context
    }

    return innerFunction;
}

let obj = { outerFunction: outerFunction };
let closureExample = obj.outerFunction();
closureExample(); // Outputs: { outerFunction: [Function: outerFunction] }
</code></pre><p>In this example, <code>outerFunction</code> saves <code>this</code> as <code>self</code> before defining <code>innerFunction</code>. When <code>innerFunction</code> is called later, it accesses <code>self</code>, which holds the correct reference to <code>obj</code>.</p><br><br><p>Another elegant solution involves <i>using arrow functions</i>. Arrow functions do not have their own <code>this</code> binding; instead, they inherit <code>this</code> from the enclosing lexical context. This feature makes arrow functions particularly useful for preserving <code>this</code> in closures. Here’s an example:</p><pre class="bg-light"><code>function outerFunction() {
    this.outerVariable = 'I am from the outer function';

    const innerFunction = () => {
        console.log(this.outerVariable); // Arrow function uses `this` from outerFunction
    };

    return innerFunction;
}

let obj = new outerFunction();
let closureExample = obj;
closureExample(); // Outputs: "I am from the outer function"
</code></pre><p>In this scenario, <code>innerFunction</code> is defined as an arrow function within <code>outerFunction</code>. The arrow function automatically uses the <code>this</code> value from <code>outerFunction</code>, ensuring the correct reference is maintained.</p><br><br><p>A third method involves using <code>Function.prototype.bind</code> to manually set the value of <code>this</code> when the closure is created. By binding <code>this</code> to the desired context, you ensure that <code>this</code> within the closure refers to the correct object, regardless of how the function is later invoked. For example:</p><pre class="bg-light"><code>function outerFunction() {
    this.outerVariable = 'I am from the outer function';

    function innerFunction() {
        console.log(this.outerVariable);
    }

    return innerFunction.bind(this); // Bind `this` to outerFunction's `this`
}

let obj = new outerFunction();
let closureExample = obj;
closureExample(); // Outputs: "I am from the outer function"
</code></pre><p>In this case, <code>innerFunction</code> is explicitly bound to the <code>this</code> value of <code>outerFunction</code> using <code>bind</code>. This ensures that when <code>innerFunction</code> is called, it accesses the correct <code>this</code> context.</p><br><br><p>Understanding these strategies is essential for effectively working with <code>this</code> in closures, ensuring that your code behaves as intended.</p><br><br><h3 id="memory_leaks">Memory Leaks</h3><p>Closures in JavaScript can sometimes lead to <i>memory issues</i> because they retain references to their enclosing scope. This means that <i>variables from the outer function are kept in memory as long as the closure exists</i>, even if the outer function has finished executing. This can cause increased memory usage, particularly in long-running applications or those that create many closures.</p><p>For example:</p><pre class="bg-light"><code>function createClosure() {
    let largeArray = new Array(1000000).fill('Some data'); // Large object

    return function() {
        console.log(largeArray[0]); // Closure retains reference to largeArray
    };
}

let closure = createClosure();
</code></pre><p>Even after <code>createClosure()</code> finishes, <code>largeArray</code> is not garbage collected because the closure holds a reference to it.</p><br><br><p>If a function repeatedly creates closures and these closures are not needed or properly managed, they can accumulate and consume memory unnecessarily. For instance:</p><pre class="bg-light"><code>let closures = [];

for (let i = 0; i < 1000; i++) {
    closures.push(function() {
        console.log(i);
    });
}
</code></pre><p>The <code>closures</code> array holds references to 1000 closures, each with its own lexical environment.</p><br><br><h4 id="managing_memory_with_closures">Managing Memory with Closures</h4><p>To avoid memory issues related to closures, consider the following strategies:</p><ul>
<li>
<p>Avoid Unnecessary Closures: Only create closures when necessary. Avoid using closures for simple tasks that do not require preserving the lexical scope.</p>
</li>
<li>
<p>Nullify References When Possible: If a closure is no longer needed, explicitly nullify references to it so that the garbage collector can reclaim the memory. Here’s an example:</p><pre class="bg-light"><code>function createClosure() {
    let largeArray = new Array(1000000).fill('Some data'); // Large object

    function closure() {
        console.log(largeArray[0]); // Closure retains reference to largeArray
    }

    function cleanup() {
        largeArray = null; // Nullify the reference when done
    }

    return { closure, cleanup };
}

let { closure, cleanup } = createClosure();
closure(); // Outputs: "Some data"

// When done with closure, call cleanup to free memory
cleanup();

</code></pre><p>In this approach, the <code>createClosure</code> function returns an <code>object</code> containing both the <code>closure</code> and a <code>cleanup</code> function. You use the <code>closure</code> as needed, and when you are finished with it, you call <code>cleanup</code> to nullify the reference to <code>largeArray</code>, ensuring that memory can be reclaimed. This way, you avoid memory leaks while still allowing the closure to function correctly until it is no longer needed.</p>
</li>
<li><p>Use Weak References: In cases where you need to hold references to closures but want to allow them to be garbage collected when no longer needed, consider using weak references if your environment supports them (e.g., <code>WeakMap</code> (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank">MDN web docs</a>)):</p><pre class="bg-light"><code>let weakMap = new WeakMap();

function createClosure() {
    let largeArray = new Array(1000000).fill('Some data'); // Large object

    let closure = function() {
        console.log(largeArray[0]); // Closure retains reference to largeArray
    };

    // Use weak reference to hold largeArray
    weakMap.set(closure, largeArray);

    return closure;
}

// Usage example
let closure = createClosure();
closure(); // Outputs: "Some data"
</code></pre><p><code>WeakMap</code> allows you to associate <code>closure</code> with <code>largeArray</code> weakly, meaning that if <code>closure</code> is the only remaining reference to <code>largeArray</code>, both can be garbage collected.</p></li>
</ul><br><br><h2 id="iife">Immediately Invoked Function Expressions</h2><p>An <i>anonymous function</i> that is called immediately is called an <b>Immediately Invoked Function Expression</b> (<b>IIFE</b>). It looks like a regular function declaration, but since it’s wrapped in parentheses, it’s treated as a function expression. The function is then immediately called using <i>another set of parentheses at the end</i>. The basic syntax looks like this:</p><pre class="bg-light"><code>(function() {
    // block code here
})();

</code></pre><p>Using an <i>Immediately Invoked Function Expression</i> (IIFE) can create a scope similar to block scope by defining and executing a function immediately. This is particularly useful in older versions of JavaScript (before ECMAScript 6) where block-scoped variables were not available. Here's an example:</p><pre class="bg-light"><code>// IIFE
(function () {
    var secret = 'hidden message';
    console.log(secret); // Outputs: 'hidden message'
})();
console.log(secret); // Throws an error
</code></pre><p>In this example, the variable <code>secret</code> is defined inside the IIFE and is not accessible outside of it. When <code>console.log(secret)</code> is called outside the IIFE, it results in an error because <code>secret</code> is not defined in that scope. This technique was especially useful to prevent variable bleed in ECMAScript 5.1 and earlier versions, and it also helps to avoid <a href="#memory_leaks">memory issues</a> related to closures by ensuring the scope chain is destroyed immediately after the function completes.</p><br><br><p>With ECMAScript 6, you don't need to use an IIFE to create block scope, because block-scoped variables (<code>let</code> and <code>const</code>) provide the same functionality:</p><pre class="bg-light"><code>{
    const secret = 'hidden message';
    console.log(secret); // Outputs: 'hidden message'
}
console.log(secret); // Throws an error
</code></pre><br><br><h2 id="private_variables">Private Variables and Functions</h2><p>Strictly speaking, JavaScript has no concept of private members; all object properties are public. There is, however, <i>a concept of private variables</i>. Any variable defined inside a function or block <i>is private</i> because it can't be accessed from outside that function. This includes function arguments, local variables, and inner functions. For example, in the function below:</p><pre class="bg-light"><code>function multiply(num1, num2) {
    let mul = num1 * num2;
    return mul;
}</code></pre><p>The variables <code>num1</code>, <code>num2</code>, and <code>mul</code> are private. They can be accessed within the function but not outside of it. If a closure is created within this function, it can access these private variables through its scope chain. This allows you to create public methods that can interact with private variables.</p><p>A <b><i>privileged method</i></b> is a public method that can access private variables and functions. One way to create privileged methods is by defining them inside a constructor function. Here’s a simple example:</p><pre class="bg-light"><code>function MyObject() {
    // Private variables and functions
    let privateVariable = 10;
    function privateFunction() {
        return false;
    }

    // Privileged method
    this.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
}
</code></pre><p>This pattern defines all private variables and functions inside the constructor. Then privileged methods can be created to access those private members. This works because the privileged methods, when defined in the constructor, become closures with full access to all variables and functions defined inside the constructor’s scope. In the example, the variable <code>privateVariable</code> and the function <code>privateFunction</code> can only be accessed by <code>publicMethod()</code>. Once an instance of <code>MyObject</code> is created, <code>privateVariable</code> and <code>privateFunction</code> can't be accessed directly; they can only be accessed through <code>publicMethod()</code>.</p><br><br><p>You can create private and privileged members to protect data from being directly modified, like in this example:</p><pre class="bg-light"><code>function Car(make) {
    // Private variable
    let carMake = make;

    // Privileged methods
    this.getMake = function() {
        return carMake;
    };

    this.setMake = function(value) {
        carMake = value;
    };
}

let myCar = new Car('Toyota');
console.log(myCar.getMake()); // Outputs: 'Toyota'
myCar.setMake('Honda');
console.log(myCar.getMake()); // Outputs: 'Honda'
</code></pre><p>In this example, <code>carMake</code> is a private variable. The methods <code>getMake</code> and <code>setMake</code> are privileged methods that allow access to the private variable <code>carMake</code>. This ensures that the <code>carMake</code> variable can only be accessed and modified through these methods, providing controlled access to the private data.</p><br><br></div>
<div class="col-sm-4"><div class="card"><div class="card-header">See also</div><div class="card-body"><div class="list-group"><a class="list-group-item list-group-item-action" href="/dom.html">DOM - Document Object Model</a><a class="list-group-item list-group-item-action" href="/script_tag.html">Inserting JavaScript into an HTML page</a><a class="list-group-item list-group-item-action" href="/variables_in_js.html">Variables in JavaScript</a><a class="list-group-item list-group-item-action active" href="/functions_javascript.html">Functions in JavaScript</a><a class="list-group-item list-group-item-action" href="/numbers_in_js.html">Numbers in JavaScript</a><a class="list-group-item list-group-item-action" href="/strings_in_js.html">Strings in JavaScript</a></div></div></div></div>
</div></div> <!--end .container-fluid --><section id="social" class="pt-4">
<footer class="text-white" style="background-color: #5865F2;">
<div class="container p-4 pb-4">
<section class="text-center">
<a href="https://discord.gg/F2pbDGJZ" class="discord-invite-btn" target="_blank" rel="noopener noreferrer">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-discord" viewBox="0 0 16 16">
<path d="M13.545 2.907a13.2 13.2 0 0 0-3.257-1.011.05.05 0 0 0-.052.025c-.141.25-.297.577-.406.833a12.2 12.2 0 0 0-3.658 0 8 8 0 0 0-.412-.833.05.05 0 0 0-.052-.025c-1.125.194-2.22.534-3.257 1.011a.04.04 0 0 0-.021.018C.356 6.024-.213 9.047.066 12.032q.003.022.021.037a13.3 13.3 0 0 0 3.995 2.02.05.05 0 0 0 .056-.019q.463-.63.818-1.329a.05.05 0 0 0-.01-.059l-.018-.011a9 9 0 0 1-1.248-.595.05.05 0 0 1-.02-.066l.015-.019q.127-.095.248-.195a.05.05 0 0 1 .051-.007c2.619 1.196 5.454 1.196 8.041 0a.05.05 0 0 1 .053.007q.121.1.248.195a.05.05 0 0 1-.004.085 8 8 0 0 1-1.249.594.05.05 0 0 0-.03.03.05.05 0 0 0 .003.041c.24.465.515.909.817 1.329a.05.05 0 0 0 .056.019 13.2 13.2 0 0 0 4.001-2.02.05.05 0 0 0 .021-.037c.334-3.451-.559-6.449-2.366-9.106a.03.03 0 0 0-.02-.019m-8.198 7.307c-.789 0-1.438-.724-1.438-1.612s.637-1.613 1.438-1.613c.807 0 1.45.73 1.438 1.613 0 .888-.637 1.612-1.438 1.612m5.316 0c-.788 0-1.438-.724-1.438-1.612s.637-1.613 1.438-1.613c.807 0 1.451.73 1.438 1.613 0 .888-.631 1.612-1.438 1.612"/>
</svg>Join Discord</a>
</section>
</div>
</footer>
</section>
<section id="donate" class="">
<footer class=" text-white" style="background-color: #0a4275;">
<div class="container p-4 pb-0">
<section class="text-center">
<p class="d-flex justify-content-center align-items-center">If you like all of this, please buy me a coffee</p>
</section>
</div>
<div class="p-3" style="background-color: rgba(0, 0, 0, 0.2);">
<div class="table-responsive">
<table class="w-100 mb-3">
<tr>
<td ><span style="user-select: none" class="text-nowrap">BTC (Bitcoin): </span></td>
<td ><span class="ms-3" id="btc_donate"></span></td>
</tr>
<tr>
<td><span style="user-select: none" class="text-nowrap">XMR (Monero): </span></td>
<td ><span class="ms-3" id="xmr_donate"></span></td>
</tr>
<tr>
<td><span style="user-select: none" class="text-nowrap">LTC (Litecoin): </span></td>
<td ><span class="ms-3" id="ltc_donate"></span></td>
</tr>
</table>
</div>
</div>
</footer>
</section></body>
</html>