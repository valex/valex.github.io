extends basic.pug

block content

    <div class="row">
        <div class="col-sm-8">
            <p>In ECMAScript, functions are objects. Each function is an instance of the <code>Function</code> type, having properties and methods like other reference types. Since functions are considered objects, their names act as pointers to function objects and aren't strictly tied to the function itself.</p>

            <p>Functions are commonly defined using the <i>function-declaration syntax</i>, as demonstrated in this example:</p>

            pre(class="bg-light")
                code.
                    function add(a, b) {
                        return a + b;
                    }

            <p>In this code, a variable <code>add</code> is defined and initialized to be a function. Notice that there's no semicolon (;) at the end. In JavaScript, when you define functions using this syntax, you don't need a semicolon after the closing brace.</p>
            
            br
            br
            
            p To define a function, you can use the <i>function expression syntax</i>, which is almost a complete equivalent to the <i>function-declaration syntax</i>:

            pre(class="bg-light")
                code.
                    let add = function(a, b) {
                        return a + b;
                    };

            p Note that there is a semicolon (;) after the end of the function.
            
            br
            br
            
            p Another way to define a function that is quite similar to a <i>function expression</i> is to use the "<i><b>arrow</b></i>" function syntax, like this:
            pre(class="bg-light")
                code.
                    let add = (a, b) => {
                        return a + b;
                    };
                    
            br
            br
            
            p To demonstrate that functions are objects and that the function name serves as a pointer to the object, there's another way to define a function:
            pre(class="bg-light")
                code.
                    // not recommended
                    let add = new Function("a", "b", "return a + b");

            p The <code>Function</code> constructor can take any number of arguments. The final argument is always treated as the function body, and the preceding arguments define the parameters for the new function.


            <div class="d-flex justify-content-between my-3">
                <div class="toc">
                    <div class="toctitle">
                        <h4>Fast links</h4>
                    </div> 
                    
                    <ul>
                        <li><a href="#arrow_functions"><span class="tocnumber">•</span> <span class="toctext">ARROW functions</span></a></li>
                        <li><a href="#function_names"><span class="tocnumber">•</span> <span class="toctext">Function names</span></a></li>
                        
                        <li>
                            <a href="#arguments"><span class="tocnumber">•</span> <span class="toctext">Arguments</span></a> 
                            <ul>
                                <li><a href="#arguments_in_arrow"><span class="tocnumber">•</span> <span class="toctext">Arguments in Arrow Functions</span></a></li>
                            </ul>
                        </li> 
                        
                        <li><a href="#default_parameter"><span class="tocnumber">•</span> <span class="toctext">Default Parameter Values</span></a></li>
                        <li><a href="#spread_arguments"><span class="tocnumber">•</span> <span class="toctext">Spread Arguments</span></a></li>
                        <li><a href="#rest_parameter"><span class="tocnumber">•</span> <span class="toctext">Rest Parameter</span></a></li>
                        <li><a href="#declaration_vs_expression"><span class="tocnumber">•</span> <span class="toctext">Differences Between Function Declarations and Function Expressions</span></a></li>
                        <li><a href="#functions_as_values"><span class="tocnumber">•</span> <span class="toctext">Functions as values</span></a></li>
                         
                                      
            
            
            
                        
                    </ul>
                </div>
            </div>

            br
            br
            
            h2(id='arrow_functions') ARROW functions

            p In ECMAScript 6, there's a new way to create function expressions using the fat-arrow syntax. Arrow functions mostly work the same as regular function expressions. You can use arrow functions anywhere you'd use a regular function expression:

            pre(class="bg-light")
                code.
                    let arrowMultiply = (x, y) => {
                        return x * y;
                    };

                    let functionExpressionMultiply = function(x, y) {
                        return x * y;
                    };

                    console.log(arrowMultiply(3, 4)); // 12
                    console.log(functionExpressionMultiply(3, 4)); // 12

            br
            br

            p Arrow functions are really handy when you want to write short and simple code, especially in inline situations:

            pre(class="bg-light")
                code.
                    let numbers = [1, 2, 3];

                    console.log(numbers.map(function(number) { return number * 2; })); // [2, 4, 6]
                    console.log(numbers.map((number) => { return number * 2 })); // [2, 4, 6]

            br
            br
            
            p Arrow functions don't need parentheses if you have just one parameter. But if you have zero or more than one parameter, you need to use parentheses:

            pre(class="bg-light")
                code.
                    // Both are valid
                    let doubleValue = (x) => { return 2 * x; };
                    let tripleValue = x => { return 3 * x; };

                    // Zero parameters require an empty pair of parentheses
                    let getRandomNumber = () => { return Math.random(); };

                    // Multiple parameters require parentheses
                    let calculateSum = (a, b) => { return a + b; };

                    // Invalid syntax:
                    let invalidMultiply = a, b => { return a * b; };
            
            br
            br
            
            p Arrow functions don't necessarily require curly braces, but choosing not to use them alters the behavior of the function. When you use curly braces, it's called "block body" syntax, and it works like a regular function expression. You can have multiple lines of code inside. If you skip the curly braces, it's the "concise body" syntax, and you're limited to just one line of code, like an assignment or expression. The value of this line will automatically be returned:

            pre(class="bg-light")
                code.
                    // Both are valid and will return the value
                    let doubleValue = (x) => { return 2 * x; };
                    let tripleValue = (x) => 3 * x;

                    // Assignment is allowed
                    let value = {};
                    let setName = (x) => x.name = "Karl";
                    setName(value);
                    console.log(value.name); // "Karl"

                    // Invalid syntax:
                    let invalidMultiply = (a, b) => return a * b;
            
            br
            br
            
            p While arrow functions are concise in syntax, they're not suitable for several situations. They don't support the use of <code>arguments</code>, <code>super</code>, or <code>new.target</code>, and they can't be used as constructors. Moreover, function objects created with the arrow syntax lack a defined <code>prototype</code> property.

            br
            br
            
            h2(id='function_names') Function names
            
            p Since function names are basically pointers to functions, they behave like any other variable holding a pointer to an object. This allows having multiple names for a single function. For instance:

            pre(class="bg-light")
                code.
                    function sum(a, b) {
                        return a + b;
                    }

                    console.log(sum(5, 10)); // 15

                    let anotherSum = sum;
                    console.log(anotherSum(5, 10)); // 15

                    sum = null;
                    console.log(anotherSum(5, 10)); // 15

            p This code creates a function called <code>sum()</code> that adds two numbers. A variable, <code>anotherSum</code>, is declared and assigned the value of <code>sum</code>. When we use the function name without parentheses, it refers to the function itself rather than executing it. At this stage, both <code>anotherSum</code> and <code>sum</code> point to the same function, so calling <code>anotherSum()</code> returns a result. When <code>sum</code> is set to <code>null</code>, it breaks its connection with the function. However, calling <code>anotherSum()</code> still works without any issues.


            br
            br
            
            h2(id='arguments') Arguments
            
            p In ECMAScript, function arguments work differently compared to many other programming languages. When you define a function in ECMAScript, it doesn't care how many arguments you pass to it or what data types those arguments are. Even if you specify a function to take two arguments, you can actually pass in any number of arguments, including one, three, or none, without causing an issue for the interpreter.

            p This flexibility exists because in ECMAScript, arguments are internally represented <i>as an array</i>. This array is always sent to the function, but the function doesn't pay attention to the contents of the array. Whether the array is empty or has multiple items, the function will still work. When you define a function using the <code>function</code> keyword (not an arrow function), there is an <code>arguments</code> object available within the function. This <code>arguments</code> object behaves like an array, allowing you to access each argument using bracket notation (<code>arguments[0]</code> for the first argument, <code>arguments[1]</code> for the second, and so on) and determine the number of arguments passed in using the <code>length</code> property.

            p In the following example, the <code>sayHello()</code> function’s first argument is named <code>name</code>:

            pre(class="bg-light")
                code.
                    function sayHello(name, message) {
                        console.log("Hello " + name + ", " + message);
                    }
                    
            br
            br
            
            p You can access the same value by using <code>arguments[0]</code>. This allows you to rewrite the function without explicitly naming the arguments, like this:
            
            pre(class="bg-light")
                code.
                    function sayHello() {
                        console.log("Hello " + arguments[0] + ", " + arguments[1]);
                    }
            
            p In this rewritten version, the specific names for the arguments have been taken out. Even without the names "<code>name</code>" and "<code>message</code>", the function will still work correctly. This shows that in ECMAScript, having named arguments is helpful but <i>not mandatory</i>.
            br
            br
            
            p You can also use the <code>arguments</code> object to count the number of arguments passed into the function using the <code>length</code> property. The next example shows how many arguments are passed into the function every time it is called:

            pre(class="bg-light")
                code.
                    function countArgs() {
                        console.log(arguments.length);
                    }

                    countArgs("apple", "banana", "orange"); // 3
                    countArgs(1, 2, 3, 4, 5); // 5
                    countArgs(true, false); // 2

            br
            br
            
            p If you don't pass a value for a <i>named argument</i> into a function, it will automatically be set as <code>undefined</code>. This is similar to creating a variable without giving it a value.

            br
            br
            
            h3(id='arguments_in_arrow') Arguments in Arrow Functions
            
            p When you use the <i>arrow function</i> notation to define a function, you can't access the passed arguments using the <code>arguments</code> keyword; you can only access them by their specific names in the function definition.

            p For example:
            pre(class="bg-light")
                code.
                    function printNumber() {
                        console.log(arguments[0]);
                    }
                    printNumber(10); // Output: 10


                    let printValue = () => {
                        console.log(arguments[0]);
                    };
                    printValue(10); // Output: ReferenceError: arguments is not defined
            br
            br
            
            p Even though the <code>arguments</code> keyword may not work in arrow functions, it's possible for the <code>arguments</code> to be accessible if they are provided from the scope of a surrounding function being called:

            p For example:
            
            pre(class="bg-light")
                code.
                    function printNumber() {
                        let printValue = () => {
                            console.log(arguments[0]);
                        };
                        printValue();
                    }

                    printNumber(10); // Output: 10
            br
            br
            
            h2(id='default_parameter') Default Parameter Values
            
            p In older versions of ECMAScript before 5.1, a popular way to set default parameter values was to check if a parameter was missing in the function call by verifying if it was <code>undefined</code>, and then assigning a value to the parameter if it was indeed undefined. For example:
            pre(class="bg-light")
                code.
                    function greetUser(userName) {
                        userName = (typeof userName !== 'undefined') ? userName : 'Guest';
                        return `Hello, ${userName}!`;
                    }
                    console.log(greetUser()); // 'Hello, Guest!'
                    console.log(greetUser('Alice')); // 'Hello, Alice!'
            br
            br
            
            p In ECMAScript 6, there is no longer a need for the previous workaround, as it allows for defining default parameter values directly in the function signature using the <code>=</code> operator. The equivalent of the previous function using ES6 default parameters would be:
            pre(class="bg-light")
                code.
                    function greetUser(userName = 'Guest') {
                        return `Hello, ${userName}!`;
                    }
                    console.log(greetUser()); // 'Hello, Guest!'
                    console.log(greetUser('Alice')); // 'Hello, Alice!'
            
            br
            br
            
            p When you pass <code>undefined</code> as an argument, it is handled similarly to not passing any argument at all. This feature enables the use of multiple independent default variables. Here's an example using ES6 default parameters:
            pre(class="bg-light")
                code.
                    function createCharacter(characterName = 'Alice', role = 'Explorer') {
                        return `${characterName} the ${role}`;
                    }
                    console.log(createCharacter()); // 'Alice the Explorer'
                    console.log(createCharacter('Bob')); // 'Bob the Explorer'
                    console.log(createCharacter(undefined, 'Wizard')); // 'Alice the Wizard'

            br
            br
            
            p When using default parameters, the <code>arguments</code> object's value does not show the default value of a parameter, but rather the actual argument passed to the function. This aligns with the behavior in ES5 strict mode and is beneficial because it maintains the values as they were passed during the function invocation:
            pre(class="bg-light")
                code.
                    function greetUser(userName = 'Guest') {
                        return `Hello, ${arguments[0]}!`;
                    }
                    console.log(greetUser()); // 'Hello, undefined!'
                    console.log(greetUser('Alice')); // 'Hello, Alice!'
            
            br
            br
            
            p You can set default parameter values to be <i>the result of a function call</i>, not just fixed values or objects:

            pre(class="bg-light")
                code.
                    let colors = ['Red', 'Blue', 'Green'];
                    let index = 0;

                    function getNextColor() {
                        return colors[index++ % colors.length];
                    }

                    function paintHouse(houseNumber, color = getNextColor()) {
                        return `House ${houseNumber} is painted ${color}`;
                    }

                    console.log(paintHouse(1)); // House 1 is painted Red
                    console.log(paintHouse(2, 'Yellow')); // House 2 is painted Yellow
                    console.log(paintHouse(3)); // House 3 is painted Blue
                    console.log(paintHouse(4)); // House 4 is painted Green

            p The default parameter value is calculated only <b><i>when the function is called</i></b>, not when it's defined. The calculation for the default value only happens if the argument is missing.
            
            br
            br
            
            p Arrow functions can also use default parameters similarly, but if a default value is set, parentheses around a single argument become mandatory:

            pre(class="bg-light")
                code.
                    let greetUser = (userName = 'Guest') => `Hello, ${userName}!`;
                    console.log(greetUser()); // Hello, Guest!
                    
            br
            br
            
            h2(id='spread_arguments') Spread Arguments
            
            p Instead of passing an array as one argument to a function, it's often helpful to split the array into individual values and pass each value separately.

            p For example, if you have a function like this that sums all the values passed as arguments:
            
            pre(class="bg-light")
                code.
                    let values = [1, 2, 3, 4];

                    function getSum() {
                        let sum = 0;
                        for (let i = 0; i < arguments.length; ++i) {
                            sum += arguments[i];
                        }
                        return sum;
                    }

            p This function expects each argument to be a single number that will be added together to find the sum. To pass an array of values to this function, you can use the <code>.apply()</code> method to flatten the array into separate parameters:
            
            pre(class="bg-light")
                code.
                    console.log(getSum.apply(null, values)); // Output: 10

            p In ECMAScript 6, you can now do this more simply using the <i>spread operator (...)</i>. When you apply the spread operator to an iterable object and pass it as a single argument to a function, it breaks down the object into individual arguments. This allows you to unpack an array directly into separate arguments within the function call. For example:

            pre(class="bg-light")
                code.
                    console.log(getSum(...values)); // 10
                    
            br
            br
            
            p Since the array size is known, you can freely place other parameters <i>before or after</i> the spread operator, including additional spread operators:


            pre(class="bg-light")
                code.
                    console.log(getSum(-1, ...values)); // Output: 9
                    console.log(getSum(...values, 5)); // Output: 15
                    console.log(getSum(-1, ...values, 5)); // Output: 14
                    console.log(getSum(...values, ...[5, 6, 7])); // Output: 28

            p In these examples, you can see how you can mix the spread operator with other parameters to pass values efficiently to the function.

            br
            br
            
            p The spread operator is not recognized by the <code>arguments</code> object; it treats the spread values as individual pieces because that's how they are passed to the function:

            pre(class="bg-light")
                code.
                    let values = [1, 2, 3, 4];

                    function countArguments() {
                        console.log(arguments.length);
                    }

                    countArguments(-1, ...values); // Output: 5
                    countArguments(...values, 5); // Output: 5
                    countArguments(-1, ...values, 5); // Output: 6
                    countArguments(...values, ...[5, 6, 7]); // Output: 7
            
              
            br
            br
            
           
            h2(id='rest_parameter') Rest Parameter
            
            p When defining a function, you can use the spread operator to combine variable-length parameters into a single array. This is similar to how the <code>arguments</code> object works, but with the spread operator, the parameters become part of a formal <code>Array</code> object:

            pre(class="bg-light")
                code.
                    function getTotal(...numbers) {
                        return numbers.reduce((sum, num) => sum + num, 0);
                    }

                    console.log(getTotal(1, 2, 3)); // Output: 6

            br
            br
            
            p If there are named parameters before the rest parameter, the rest parameter will capture the remaining unnamed parameters as an array, or it will be an empty array if there are no remaining parameters. The rest parameter must always be the last formal parameter because it can vary in size.

            p Here's a simple example to illustrate this concept:

            pre(class="bg-light")
                code.
                    function printValues(first, second, ...rest) {
                        console.log("First:", first);
                        console.log("Second:", second);
                        console.log("Rest:", rest);
                    }

                    printValues(1, 2, 3, 4, 5);
                    // Output:
                    // First: 1
                    // Second: 2
                    // Rest: [3, 4, 5]
              
            br
            br
            
            p While arrow functions do not support the <code>arguments</code> object, they do support <i>rest parameters</i>, providing functionality that closely resembles <code>arguments</code>:

            pre(class="bg-light")
                code.
                    const sumValues = (...args) => {
                        return args.reduce((total, num) => total + num, 0);
                    };

                    console.log(sumValues(1, 2, 3, 4)); // Output: 10
            
              
            br
            br
            
            p As expected, using a <i>rest parameter</i> does not impact the <code>arguments</code> object — it will continue to reflect exactly what was passed to the function:

            pre(class="bg-light")
                code.
                    function exampleFunction(...args) {
                        console.log("Rest Parameter:", args);
                        console.log("Arguments Object:", arguments);
                    }

                    exampleFunction(1, 2, 3);

                    // Output:
                    // Rest Parameter: Array(3) [ 1, 2, 3 ]
                    // Arguments Object:Arguments { 0: 1, 1: 2, 2: 3, … }
              
             
            br
            br
            
            h2(id='declaration_vs_expression') Differences Between Function Declarations and Function Expressions
            
            p <i>Function declarations</i> and <i>function expressions</i> are similar in many ways, but there is a crucial difference in how JavaScript engines handle them. <i>Function declarations</i> are loaded and available in the execution context before any code is executed, thanks to a process called <b><i>function declaration hoisting</i></b>. On the other hand, <i>function expressions</i> are not fully defined until the code execution reaches that line.

            p For example:

            pre(class="bg-light")
                code.
                    // Function Declaration - OK
                    console.log(multiplyNumbers(3, 5));
                    function multiplyNumbers(a, b) {
                        return a * b;
                    }

                    // Function Expression - Error
                    console.log(multiplyNumbers(3, 5));
                    let multiplyNumbers = function(a, b) {
                        return a * b;
                    };
                    
            p In the first case, the <i>function declaration</i> works fine due to <b><i>hoisting</i></b>, while in the second case, using a <i>function expression</i> causes an error because the function isn't available until the line where it's defined is executed. This issue occurs regardless of using <code>let</code> or <code>var</code>.

            p Apart from this availability difference, <i>function declarations</i> and <i>function expressions</i> are essentially equivalent in functionality.

            br
            br
            
            h2(id='functions_as_values') Functions as values
            
            p In ECMAScript, functions are like <i>variables</i>, so you can use them just like you would use variables. This allows you to pass a function <i>as an argument</i> to another function and even return a function as the result of another function. Consider the following function:

            pre(class="bg-light")
                code.
                    function applyOperation(operation, number) {
                        return operation(number);
                    }

            p This function takes two arguments. The first argument should be a function, and the second argument should be a value to pass to that function. You can pass any function in this way:

            pre(class="bg-light")
                code.
                    function squareNumber(x) {
                        return x * x;
                    }

                    let result1 = applyOperation(squareNumber, 5);
                    console.log(result1); // Output: 25

                    function greetPerson(personName) {
                        return "Hello, " + personName;
                    }

                    let result2 = applyOperation(greetPerson, "Alice");
                    console.log(result2); // Output: "Hello, Alice"

            p The <code>applyOperation()</code> function is generic, meaning it doesn't matter which function is passed as the first argument — the result will always come from executing the first argument. To pass a <i>function pointer</i> instead of executing the function, you should omit the parentheses. This way, the variables <code>squareNumber</code> and <code>greetPerson</code> are passed into <code>applyOperation()</code> without executing them.
            
            br
            br
            
            p Returning a function from a function is a useful capability. For example, if you have an array of objects and need to sort it based on a specific object property, you can create a comparison function dynamically. The <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort()</a></code> method of an array requires a comparison function that compares two values, but you may need to specify <i>which property to sort by</i>. This can be solved by creating a function that generates a comparison function based on a property name, as in the following example:

            pre(class="bg-light")
                code.
                    function createSortingFunction(property) {
                        return function(obj1, obj2) {
                            let value1 = obj1[property];
                            let value2 = obj2[property];
                            if (value1 < value2) {
                                return -1;
                            } else if (value1 > value2) {
                                return 1;
                            } else {
                                return 0;
                            }
                        };
                    }

            p The syntax of this function may seem complex, but it's simply a function inside of a function, with the outer function returning the inner function. The <code>property</code> argument is accessible within the inner function and is used with bracket notation to access the property values for comparison. Once the <code>property</code> values are obtained, a straightforward comparison can be performed.

            p Here's an example of how this function can be used:

            pre(class="bg-light")
                code.
                    let people = [
                        {name: "Emma", age: 28},
                        {name: "David", age: 29}
                    ];

                    people.sort(createSortingFunction("name"));
                    console.log(people[0].name); // Output: David

                    people.sort(createSortingFunction("age"));
                    console.log(people[0].name); // Output: Emma

            p In this code, an array named <code>people</code> is defined with two objects, each containing a <code>name</code> and an <code>age</code> property. By default, the <code>sort()</code> method would use <code>toString()</code> to sort the objects, which might not provide the desired order.

            p When <code>createSortingFunction("name")</code> is invoked, it generates a comparison function that sorts the objects based on the <code>name</code> property. Consequently, the first item in the sorted array will have the name "David".

            p On the other hand, calling <code>createSortingFunction("age")</code> creates a comparison function that sorts the objects based on the <code>age</code> property. This results in the first item being the one with the name "Emma" and an age of 28.


            br
            br
        </div>

        <div class="col-sm-4">

            include see_also.pug
            
        </div>
    </div>
