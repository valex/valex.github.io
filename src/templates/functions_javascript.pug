extends basic.pug

block content

    <div class="row">
        <div class="col-sm-8">
            <p>In ECMAScript, functions are objects. Each function is an instance of the <code>Function</code> type, having properties and methods like other reference types. Since functions are considered objects, their names act as pointers to function objects and aren't strictly tied to the function itself.</p>

            <p>Functions are commonly defined using the <i>function-declaration syntax</i>, as demonstrated in this example:</p>

            pre(class="bg-light")
                code.
                    function add(a, b) {
                        return a + b;
                    }

            <p>In this code, a variable <code>add</code> is defined and initialized to be a function. Notice that there's no semicolon (;) at the end. In JavaScript, when you define functions using this syntax, you don't need a semicolon after the closing brace.</p>
            
            br
            br
            
            p To define a function, you can use the <i>function expression syntax</i>, which is almost a complete equivalent to the <i>function-declaration syntax</i>:

            pre(class="bg-light")
                code.
                    let add = function(a, b) {
                        return a + b;
                    };

            p Note that there is a semicolon (;) after the end of the function.
            
            br
            br
            
            p Another way to define a function that is quite similar to a <i>function expression</i> is to use the "<i><b>arrow</b></i>" function syntax, like this:
            pre(class="bg-light")
                code.
                    let add = (a, b) => {
                        return a + b;
                    };
                    
            br
            br
            
            p To demonstrate that functions are objects and that the function name serves as a pointer to the object, there's another way to define a function:
            pre(class="bg-light")
                code.
                    // not recommended
                    let add = new Function("a", "b", "return a + b");

            p The <code>Function</code> constructor can take any number of arguments. The final argument is always treated as the function body, and the preceding arguments define the parameters for the new function.


            <div class="d-flex justify-content-between my-3">
                <div class="toc">
                    <div class="toctitle">
                        <h4>Fast links</h4>
                    </div> 
                    
                    <ul>
                        <li><a href="#arrow_functions"><span class="tocnumber">•</span> <span class="toctext">ARROW functions</span></a></li>
                        <li><a href="#function_names"><span class="tocnumber">•</span> <span class="toctext">Function names</span></a></li>
                        
                        <li>
                            <a href="#arguments"><span class="tocnumber">•</span> <span class="toctext">Arguments</span></a> 
                            <ul>
                                <li><a href="#arguments_in_arrow"><span class="tocnumber">•</span> <span class="toctext">Arguments in Arrow Functions</span></a></li>
                            </ul>
                        </li> 
                        
                        <li><a href="#default_parameter"><span class="tocnumber">•</span> <span class="toctext">Default Parameter Values</span></a></li>
                        <li><a href="#spread_arguments"><span class="tocnumber">•</span> <span class="toctext">Spread Arguments</span></a></li>
                        <li><a href="#rest_parameter"><span class="tocnumber">•</span> <span class="toctext">Rest Parameter</span></a></li>
                        <li><a href="#declaration_vs_expression"><span class="tocnumber">•</span> <span class="toctext">Differences Between Function Declarations and Function Expressions</span></a></li>
                        <li><a href="#functions_as_values"><span class="tocnumber">•</span> <span class="toctext">Functions as values</span></a></li>
                         
                        <li>
                            <a href="#function_inside"><span class="tocnumber">•</span> <span class="toctext">Inside a function</span></a> 
                            <ul>
                                <li><a href="#function_inside_arguments"><span class="tocnumber">•</span> <span class="toctext">arguments</span></a></li>
                                <li><a href="#function_inside_this"><span class="tocnumber">•</span> <span class="toctext">this</span></a></li>
                                <li><a href="#function_inside_caller"><span class="tocnumber">•</span> <span class="toctext">caller</span></a></li>
                                <li><a href="#function_inside_new_target"><span class="tocnumber">•</span> <span class="toctext">new.target</span></a></li>
                            </ul>
                        </li> 
                        <li>
                            <a href="#props_methods"><span class="tocnumber">•</span> <span class="toctext">Properties and methods</span></a> 
                            <ul>
                                <li><a href="#method_apply"><span class="tocnumber">•</span> <span class="toctext">apply()</span></a></li>
                                <li><a href="#method_call"><span class="tocnumber">•</span> <span class="toctext">call()</span></a></li>
                                <li><a href="#method_bind"><span class="tocnumber">•</span> <span class="toctext">bind()</span></a></li>
                            </ul>
                        </li> 
                        <li><a href="#function_expressions"><span class="tocnumber">•</span> <span class="toctext">Function expressions</span></a></li>
                    </ul>
                </div>
            </div>

            br
            br
            
            h2(id='arrow_functions') ARROW functions

            p In ECMAScript 6, there's a new way to create function expressions using the fat-arrow syntax. Arrow functions mostly work the same as regular function expressions. You can use arrow functions anywhere you'd use a regular function expression:

            pre(class="bg-light")
                code.
                    let arrowMultiply = (x, y) => {
                        return x * y;
                    };

                    let functionExpressionMultiply = function(x, y) {
                        return x * y;
                    };

                    console.log(arrowMultiply(3, 4)); // 12
                    console.log(functionExpressionMultiply(3, 4)); // 12

            br
            br

            p Arrow functions are really handy when you want to write short and simple code, especially in inline situations:

            pre(class="bg-light")
                code.
                    let numbers = [1, 2, 3];

                    console.log(numbers.map(function(number) { return number * 2; })); // [2, 4, 6]
                    console.log(numbers.map((number) => { return number * 2 })); // [2, 4, 6]

            br
            br
            
            p Arrow functions don't need parentheses if you have just one parameter. But if you have zero or more than one parameter, you need to use parentheses:

            pre(class="bg-light")
                code.
                    // Both are valid
                    let doubleValue = (x) => { return 2 * x; };
                    let tripleValue = x => { return 3 * x; };

                    // Zero parameters require an empty pair of parentheses
                    let getRandomNumber = () => { return Math.random(); };

                    // Multiple parameters require parentheses
                    let calculateSum = (a, b) => { return a + b; };

                    // Invalid syntax:
                    let invalidMultiply = a, b => { return a * b; };
            
            br
            br
            
            p Arrow functions don't necessarily require curly braces, but choosing not to use them alters the behavior of the function. When you use curly braces, it's called "block body" syntax, and it works like a regular function expression. You can have multiple lines of code inside. If you skip the curly braces, it's the "concise body" syntax, and you're limited to just one line of code, like an assignment or expression. The value of this line will automatically be returned:

            pre(class="bg-light")
                code.
                    // Both are valid and will return the value
                    let doubleValue = (x) => { return 2 * x; };
                    let tripleValue = (x) => 3 * x;

                    // Assignment is allowed
                    let value = {};
                    let setName = (x) => x.name = "Karl";
                    setName(value);
                    console.log(value.name); // "Karl"

                    // Invalid syntax:
                    let invalidMultiply = (a, b) => return a * b;
            
            br
            br
            
            p While arrow functions are concise in syntax, they're not suitable for several situations. They don't support the use of <code>arguments</code>, <code>super</code>, or <code>new.target</code>, and they can't be used as constructors. Moreover, function objects created with the arrow syntax lack a defined <code>prototype</code> property.

            br
            br
            
            h2(id='function_names') Function names
            
            p Since function names are basically pointers to functions, they behave like any other variable holding a pointer to an object. This allows having multiple names for a single function. For instance:

            pre(class="bg-light")
                code.
                    function sum(a, b) {
                        return a + b;
                    }

                    console.log(sum(5, 10)); // 15

                    let anotherSum = sum;
                    console.log(anotherSum(5, 10)); // 15

                    sum = null;
                    console.log(anotherSum(5, 10)); // 15

            p This code creates a function called <code>sum()</code> that adds two numbers. A variable, <code>anotherSum</code>, is declared and assigned the value of <code>sum</code>. When we use the function name without parentheses, it refers to the function itself rather than executing it. At this stage, both <code>anotherSum</code> and <code>sum</code> point to the same function, so calling <code>anotherSum()</code> returns a result. When <code>sum</code> is set to <code>null</code>, it breaks its connection with the function. However, calling <code>anotherSum()</code> still works without any issues.


            br
            br
            
            h2(id='arguments') Arguments
            
            p In ECMAScript, function arguments work differently compared to many other programming languages. When you define a function in ECMAScript, it doesn't care how many arguments you pass to it or what data types those arguments are. Even if you specify a function to take two arguments, you can actually pass in any number of arguments, including one, three, or none, without causing an issue for the interpreter.

            p This flexibility exists because in ECMAScript, arguments are internally represented <i>as an array</i>. This array is always sent to the function, but the function doesn't pay attention to the contents of the array. Whether the array is empty or has multiple items, the function will still work. When you define a function using the <code>function</code> keyword (not an arrow function), there is an <code>arguments</code> object available within the function. This <code>arguments</code> object behaves like an array, allowing you to access each argument using bracket notation (<code>arguments[0]</code> for the first argument, <code>arguments[1]</code> for the second, and so on) and determine the number of arguments passed in using the <code>length</code> property.

            p In the following example, the <code>sayHello()</code> function’s first argument is named <code>name</code>:

            pre(class="bg-light")
                code.
                    function sayHello(name, message) {
                        console.log("Hello " + name + ", " + message);
                    }
                    
            br
            br
            
            p You can access the same value by using <code>arguments[0]</code>. This allows you to rewrite the function without explicitly naming the arguments, like this:
            
            pre(class="bg-light")
                code.
                    function sayHello() {
                        console.log("Hello " + arguments[0] + ", " + arguments[1]);
                    }
            
            p In this rewritten version, the specific names for the arguments have been taken out. Even without the names "<code>name</code>" and "<code>message</code>", the function will still work correctly. This shows that in ECMAScript, having named arguments is helpful but <i>not mandatory</i>.
            br
            br
            
            p You can also use the <code>arguments</code> object to count the number of arguments passed into the function using the <code>length</code> property. The next example shows how many arguments are passed into the function every time it is called:

            pre(class="bg-light")
                code.
                    function countArgs() {
                        console.log(arguments.length);
                    }

                    countArgs("apple", "banana", "orange"); // 3
                    countArgs(1, 2, 3, 4, 5); // 5
                    countArgs(true, false); // 2

            br
            br
            
            p If you don't pass a value for a <i>named argument</i> into a function, it will automatically be set as <code>undefined</code>. This is similar to creating a variable without giving it a value.

            br
            br
            
            h3(id='arguments_in_arrow') Arguments in Arrow Functions
            
            p When you use the <i>arrow function</i> notation to define a function, you can't access the passed arguments using the <code>arguments</code> keyword; you can only access them by their specific names in the function definition.

            p For example:
            pre(class="bg-light")
                code.
                    function printNumber() {
                        console.log(arguments[0]);
                    }
                    printNumber(10); // Output: 10


                    let printValue = () => {
                        console.log(arguments[0]);
                    };
                    printValue(10); // Output: ReferenceError: arguments is not defined
            br
            br
            
            p Even though the <code>arguments</code> keyword may not work in arrow functions, it's possible for the <code>arguments</code> to be accessible if they are provided from the scope of a surrounding function being called:

            p For example:
            
            pre(class="bg-light")
                code.
                    function printNumber() {
                        let printValue = () => {
                            console.log(arguments[0]);
                        };
                        printValue();
                    }

                    printNumber(10); // Output: 10
            br
            br
            
            h2(id='default_parameter') Default Parameter Values
            
            p In older versions of ECMAScript before 5.1, a popular way to set default parameter values was to check if a parameter was missing in the function call by verifying if it was <code>undefined</code>, and then assigning a value to the parameter if it was indeed undefined. For example:
            pre(class="bg-light")
                code.
                    function greetUser(userName) {
                        userName = (typeof userName !== 'undefined') ? userName : 'Guest';
                        return `Hello, ${userName}!`;
                    }
                    console.log(greetUser()); // 'Hello, Guest!'
                    console.log(greetUser('Alice')); // 'Hello, Alice!'
            br
            br
            
            p In ECMAScript 6, there is no longer a need for the previous workaround, as it allows for defining default parameter values directly in the function signature using the <code>=</code> operator. The equivalent of the previous function using ES6 default parameters would be:
            pre(class="bg-light")
                code.
                    function greetUser(userName = 'Guest') {
                        return `Hello, ${userName}!`;
                    }
                    console.log(greetUser()); // 'Hello, Guest!'
                    console.log(greetUser('Alice')); // 'Hello, Alice!'
            
            br
            br
            
            p When you pass <code>undefined</code> as an argument, it is handled similarly to not passing any argument at all. This feature enables the use of multiple independent default variables. Here's an example using ES6 default parameters:
            pre(class="bg-light")
                code.
                    function createCharacter(characterName = 'Alice', role = 'Explorer') {
                        return `${characterName} the ${role}`;
                    }
                    console.log(createCharacter()); // 'Alice the Explorer'
                    console.log(createCharacter('Bob')); // 'Bob the Explorer'
                    console.log(createCharacter(undefined, 'Wizard')); // 'Alice the Wizard'

            br
            br
            
            p When using default parameters, the <code>arguments</code> object's value does not show the default value of a parameter, but rather the actual argument passed to the function. This aligns with the behavior in ES5 strict mode and is beneficial because it maintains the values as they were passed during the function invocation:
            pre(class="bg-light")
                code.
                    function greetUser(userName = 'Guest') {
                        return `Hello, ${arguments[0]}!`;
                    }
                    console.log(greetUser()); // 'Hello, undefined!'
                    console.log(greetUser('Alice')); // 'Hello, Alice!'
            
            br
            br
            
            p You can set default parameter values to be <i>the result of a function call</i>, not just fixed values or objects:

            pre(class="bg-light")
                code.
                    let colors = ['Red', 'Blue', 'Green'];
                    let index = 0;

                    function getNextColor() {
                        return colors[index++ % colors.length];
                    }

                    function paintHouse(houseNumber, color = getNextColor()) {
                        return `House ${houseNumber} is painted ${color}`;
                    }

                    console.log(paintHouse(1)); // House 1 is painted Red
                    console.log(paintHouse(2, 'Yellow')); // House 2 is painted Yellow
                    console.log(paintHouse(3)); // House 3 is painted Blue
                    console.log(paintHouse(4)); // House 4 is painted Green

            p The default parameter value is calculated only <b><i>when the function is called</i></b>, not when it's defined. The calculation for the default value only happens if the argument is missing.
            
            br
            br
            
            p Arrow functions can also use default parameters similarly, but if a default value is set, parentheses around a single argument become mandatory:

            pre(class="bg-light")
                code.
                    let greetUser = (userName = 'Guest') => `Hello, ${userName}!`;
                    console.log(greetUser()); // Hello, Guest!
                    
            br
            br
            
            h2(id='spread_arguments') Spread Arguments
            
            p Instead of passing an array as one argument to a function, it's often helpful to split the array into individual values and pass each value separately.

            p For example, if you have a function like this that sums all the values passed as arguments:
            
            pre(class="bg-light")
                code.
                    let values = [1, 2, 3, 4];

                    function getSum() {
                        let sum = 0;
                        for (let i = 0; i < arguments.length; ++i) {
                            sum += arguments[i];
                        }
                        return sum;
                    }

            p This function expects each argument to be a single number that will be added together to find the sum. To pass an array of values to this function, you can use the <code>.apply()</code> method to flatten the array into separate parameters:
            
            pre(class="bg-light")
                code.
                    console.log(getSum.apply(null, values)); // Output: 10

            p In ECMAScript 6, you can now do this more simply using the <i>spread operator (...)</i>. When you apply the spread operator to an iterable object and pass it as a single argument to a function, it breaks down the object into individual arguments. This allows you to unpack an array directly into separate arguments within the function call. For example:

            pre(class="bg-light")
                code.
                    console.log(getSum(...values)); // 10
                    
            br
            br
            
            p Since the array size is known, you can freely place other parameters <i>before or after</i> the spread operator, including additional spread operators:


            pre(class="bg-light")
                code.
                    console.log(getSum(-1, ...values)); // Output: 9
                    console.log(getSum(...values, 5)); // Output: 15
                    console.log(getSum(-1, ...values, 5)); // Output: 14
                    console.log(getSum(...values, ...[5, 6, 7])); // Output: 28

            p In these examples, you can see how you can mix the spread operator with other parameters to pass values efficiently to the function.

            br
            br
            
            p The spread operator is not recognized by the <code>arguments</code> object; it treats the spread values as individual pieces because that's how they are passed to the function:

            pre(class="bg-light")
                code.
                    let values = [1, 2, 3, 4];

                    function countArguments() {
                        console.log(arguments.length);
                    }

                    countArguments(-1, ...values); // Output: 5
                    countArguments(...values, 5); // Output: 5
                    countArguments(-1, ...values, 5); // Output: 6
                    countArguments(...values, ...[5, 6, 7]); // Output: 7
            
              
            br
            br
            
           
            h2(id='rest_parameter') Rest Parameter
            
            p When defining a function, you can use the spread operator to combine variable-length parameters into a single array. This is similar to how the <code>arguments</code> object works, but with the spread operator, the parameters become part of a formal <code>Array</code> object:

            pre(class="bg-light")
                code.
                    function getTotal(...numbers) {
                        return numbers.reduce((sum, num) => sum + num, 0);
                    }

                    console.log(getTotal(1, 2, 3)); // Output: 6

            br
            br
            
            p If there are named parameters before the rest parameter, the rest parameter will capture the remaining unnamed parameters as an array, or it will be an empty array if there are no remaining parameters. The rest parameter must always be the last formal parameter because it can vary in size.

            p Here's a simple example to illustrate this concept:

            pre(class="bg-light")
                code.
                    function printValues(first, second, ...rest) {
                        console.log("First:", first);
                        console.log("Second:", second);
                        console.log("Rest:", rest);
                    }

                    printValues(1, 2, 3, 4, 5);
                    // Output:
                    // First: 1
                    // Second: 2
                    // Rest: [3, 4, 5]
              
            br
            br
            
            p While arrow functions do not support the <code>arguments</code> object, they do support <i>rest parameters</i>, providing functionality that closely resembles <code>arguments</code>:

            pre(class="bg-light")
                code.
                    const sumValues = (...args) => {
                        return args.reduce((total, num) => total + num, 0);
                    };

                    console.log(sumValues(1, 2, 3, 4)); // Output: 10
            
              
            br
            br
            
            p As expected, using a <i>rest parameter</i> does not impact the <code>arguments</code> object — it will continue to reflect exactly what was passed to the function:

            pre(class="bg-light")
                code.
                    function exampleFunction(...args) {
                        console.log("Rest Parameter:", args);
                        console.log("Arguments Object:", arguments);
                    }

                    exampleFunction(1, 2, 3);

                    // Output:
                    // Rest Parameter: Array(3) [ 1, 2, 3 ]
                    // Arguments Object:Arguments { 0: 1, 1: 2, 2: 3, … }
              
             
            br
            br
            
            h2(id='declaration_vs_expression') Differences Between Function Declarations and Function Expressions
            
            p <i>Function declarations</i> and <i>function expressions</i> are similar in many ways, but there is a crucial difference in how JavaScript engines handle them. <i>Function declarations</i> are loaded and available in the execution context before any code is executed, thanks to a process called <b><i>function declaration hoisting</i></b>. On the other hand, <i>function expressions</i> are not fully defined until the code execution reaches that line.

            p For example:

            pre(class="bg-light")
                code.
                    // Function Declaration - OK
                    console.log(multiplyNumbers(3, 5));
                    function multiplyNumbers(a, b) {
                        return a * b;
                    }

                    // Function Expression - Error
                    console.log(multiplyNumbers(3, 5));
                    let multiplyNumbers = function(a, b) {
                        return a * b;
                    };
                    
            p In the first case, the <i>function declaration</i> works fine due to <b><i>hoisting</i></b>, while in the second case, using a <i>function expression</i> causes an error because the function isn't available until the line where it's defined is executed. This issue occurs regardless of using <code>let</code> or <code>var</code>.

            p Apart from this availability difference, <i>function declarations</i> and <i>function expressions</i> are essentially equivalent in functionality.

            br
            br
            
            h2(id='functions_as_values') Functions as values
            
            p In ECMAScript, functions are like <i>variables</i>, so you can use them just like you would use variables. This allows you to pass a function <i>as an argument</i> to another function and even return a function as the result of another function. Consider the following function:

            pre(class="bg-light")
                code.
                    function applyOperation(operation, number) {
                        return operation(number);
                    }

            p This function takes two arguments. The first argument should be a function, and the second argument should be a value to pass to that function. You can pass any function in this way:

            pre(class="bg-light")
                code.
                    function squareNumber(x) {
                        return x * x;
                    }

                    let result1 = applyOperation(squareNumber, 5);
                    console.log(result1); // Output: 25

                    function greetPerson(personName) {
                        return "Hello, " + personName;
                    }

                    let result2 = applyOperation(greetPerson, "Alice");
                    console.log(result2); // Output: "Hello, Alice"

            p The <code>applyOperation()</code> function is generic, meaning it doesn't matter which function is passed as the first argument — the result will always come from executing the first argument. To pass a <i>function pointer</i> instead of executing the function, you should omit the parentheses. This way, the variables <code>squareNumber</code> and <code>greetPerson</code> are passed into <code>applyOperation()</code> without executing them.
            
            br
            br
            
            p Returning a function from a function is a useful capability. For example, if you have an array of objects and need to sort it based on a specific object property, you can create a comparison function dynamically. The <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank">sort()</a></code> method of an array requires a comparison function that compares two values, but you may need to specify <i>which property to sort by</i>. This can be solved by creating a function that generates a comparison function based on a property name, as in the following example:

            pre(class="bg-light")
                code.
                    function createSortingFunction(property) {
                        return function(obj1, obj2) {
                            let value1 = obj1[property];
                            let value2 = obj2[property];
                            if (value1 < value2) {
                                return -1;
                            } else if (value1 > value2) {
                                return 1;
                            } else {
                                return 0;
                            }
                        };
                    }

            p The syntax of this function may seem complex, but it's simply a function inside of a function, with the outer function returning the inner function. The <code>property</code> argument is accessible within the inner function and is used with bracket notation to access the property values for comparison. Once the <code>property</code> values are obtained, a straightforward comparison can be performed.

            p Here's an example of how this function can be used:

            pre(class="bg-light")
                code.
                    let people = [
                        {name: "Emma", age: 28},
                        {name: "David", age: 29}
                    ];

                    people.sort(createSortingFunction("name"));
                    console.log(people[0].name); // Output: David

                    people.sort(createSortingFunction("age"));
                    console.log(people[0].name); // Output: Emma

            p In this code, an array named <code>people</code> is defined with two objects, each containing a <code>name</code> and an <code>age</code> property. By default, the <code>sort()</code> method would use <code>toString()</code> to sort the objects, which might not provide the desired order.

            p When <code>createSortingFunction("name")</code> is invoked, it generates a comparison function that sorts the objects based on the <code>name</code> property. Consequently, the first item in the sorted array will have the name "David".

            p On the other hand, calling <code>createSortingFunction("age")</code> creates a comparison function that sorts the objects based on the <code>age</code> property. This results in the first item being the one with the name "Emma" and an age of 28.


            br
            br
            

            h2(id='function_inside') Inside a function
            
            p Inside a function in JavaScript, there are several special objects that provide additional context and functionality within a function, allowing you to access arguments, refer to the function itself, and determine the calling context.

            br
            br
            
            h3(id='function_inside_arguments') arguments
            
            p The <code>arguments</code> object is <i>like an array</i> that holds all the values passed into a function (<a href="#arguments">Learn more</a>). It's there when you define a function using the <code>function</code> keyword (not with arrow functions). Besides storing the function's arguments, it also has a property called <code>callee</code> <small>(<code>arguments.callee</code> property is deprecated in modern JavaScript and should be avoided)</small>, which points back to the function itself. Let's look at a typical factorial function as an example:
            pre(class="bg-light")
                code.
                    function factorial(num) {
                        if (num <= 1) {
                            return 1;
                        } else {
                            return num * factorial(num - 1);
                        }
                    }
                    
            p Factorial functions are usually recursive, like in this example. It works well when the function name is fixed as "<code>factorial</code>". However, the function's proper execution is closely tied to this specific name. To make it more flexible, you can use <code>arguments.callee</code> to decouple it from the function name:

            pre(class="bg-light")
                code.
                    function factorial(num) {
                        if (num <= 1) {
                            return 1;
                        } else {
                            return num * arguments.callee(num - 1);
                        }
                    }

            p In this updated version of the <code>factorial()</code> function, the function no longer directly references its own name "<code>factorial</code>" within the function body. This change guarantees that the recursive call will always be made to the correct function, regardless of how the function is named or referenced.
            br
            br
            
            p In strict mode, the value of <code>arguments.callee</code> is not accessible and attempting to read it will result in an error. To overcome this limitation, you can utilize <i>named function expressions</i> to achieve the same result. Here is an example:
            pre(class="bg-light")
                code.
                    const factorial = (function f(num) {
                        if (num <= 1) {
                            return 1;
                        } else {
                            return num * f(num - 1);
                        }
                    });
                    
            p In this code, a named function expression <code>f()</code> is created and assigned to the variable <code>factorial</code>. The name <code>f</code> remains the same even if the function is assigned to another variable, so the recursive call will always execute correctly. This pattern works in both nonstrict mode and strict mode.

            br
            br
            
            h3(id='function_inside_this') this
            
            p In JavaScript, the special object <code>this</code> works differently in standard functions and arrow functions.

            p In a standard function, <code>this</code> refers to the object the function is working with. When used globally, <code>this</code> points to the <code>window</code> object. Consider the following:

            pre(class="bg-light")
                code.
                    window.brand = 'Toyota';

                    let car = {
                        brand: 'Ford'
                    };

                    function displayBrand() {
                        console.log(this.brand);
                    }
                    
                    displayBrand(); // 'Toyota'
                    
                    car.displayBrand = displayBrand;
                    car.displayBrand(); // 'Ford'

            p When the function <code>displayBrand()</code> is called globally, it outputs <code>"Toyota"</code> because <code>this</code> points to the <code>window</code> object, and <code>this.brand</code> evaluates to <code>window.brand</code>. Once the <code>displayBrand()</code> function is assigned to the <code>car</code> object and called through <code>car.displayBrand()</code>, <code>this</code> now refers to the <code>car</code> object, and <code>this.brand</code> evaluates to <code>car.brand</code>, resulting in the output <code>"Ford"</code>.
            
            br
            br
            
            p Inside an arrow function, <code>this</code> refers to the context in which the arrow function expression is defined. This concept is illustrated in the following example, where two separate invocations of <code>displayBrand</code> both access the property of the <code>window</code> object, which represents the context where the arrow function was originally defined.

            pre(class="bg-light")
                code.
                    window.brand = 'Toyota';

                    let car = {
                        brand: 'Ford'
                    };

                    let displayBrand = () => console.log(this.brand);


                    displayBrand(); // 'Toyota'

                    car.displayBrand = displayBrand;
                    car.displayBrand(); // 'Toyota'

            br
            br
            
            p This is especially useful in situations where events or timeouts will invoke a function inside a callback where the invoking object is not the intended object. When an arrow function is used in these situations, the context referenced by <code>this</code> is preserved:

            pre(class="bg-light")
                code.
                    function Emperor() {
                        this.royaltyName = 'Julius';
                        // 'this' will refer to the Emperor instance
                        setTimeout(() => console.log(this.royaltyName), 1000);
                    }

                    function Empress() {
                        this.royaltyName = 'Cleopatra';
                        // 'this' will refer to the window object
                        setTimeout(function() { console.log(this.royaltyName); }, 1000);
                    }

                    new Emperor(); // Output: 'Julius'
                    new Empress(); // Output: 'undefined'
            
            br
            br
            
            h3(id='function_inside_caller') caller
            
            p The <code>caller</code> property holds a reference to the function that invoked the current function, or it is <code>null</code> if the function was called from the global scope:

            pre(class="bg-light")
                code.
                    function outer() {
                        inner();
                    }
                    
                    function inner() {
                        console.log(inner.caller);
                    }
                    outer(); //  will display the source text of the outer() function

            p This code displays an alert with the source text of the <code>outer()</code> function. This is because <code>outer()</code> calls <code>inner()</code>, and <code>inner.caller</code> refers back to <code>outer()</code>.
            
            br
            br
            
            h3(id='function_inside_new_target') new.target
            
            p In JavaScript, functions can act as constructors to create new objects or as regular callable functions. A new feature introduced in ECMAScript 6 is the <code>new.target</code> property, which allows you to determine if a function was invoked with the <code>new</code> keyword.

            p If a function is called normally, <code>new.target</code> will be <code>undefined</code>. However, if a function is called using the <code>new</code> keyword, <code>new.target</code> will reference the constructor or function itself.

            p This feature provides a way to differentiate between regular function calls and constructor calls in JavaScript:

            pre(class="bg-light")
                code.
                    function Emperor() {
                        if ( ! new.target) {
                            throw 'Emperor must be instantiated using "new"';
                        }
                        console.log('Emperor instantiated using "new"');
                    }

                    new Emperor(); // Output: Emperor instantiated using "new"
                    // Emperor(); // Throws an error: Emperor must be instantiated using "new"

            br
            br
            
           
            h2(id='props_methods') Properties and methods
            
            p In ECMAScript, functions are treated <i>as objects</i>, which means they have <b>properties</b> and <b>methods</b>. Every function in JavaScript has two key properties: <code>length</code> and <code>prototype</code>. The <code>length</code> property specifies the number of named arguments that the function expects, as illustrated in the following example:

            pre(class="bg-light")
                code.
                    function greetUser(user) {
                        console.log("Hello, " + user);
                    }

                    function calculateTotal(price, quantity) {
                        return price * quantity;
                    }

                    function sayHello() {
                        console.log("Hello there!");
                    }

                    console.log(greetUser.length); // Output: 1
                    console.log(calculateTotal.length); // Output: 2
                    console.log(sayHello.length); // Output: 0

            p In this code snippet, there are three functions defined, each with a different number of named arguments. The <code>greetUser()</code> function expects one argument, so its <code>length</code> property is set to 1. Similarly, the <code>calculateTotal()</code> function requires two arguments, resulting in a <code>length</code> property of 2. Lastly, the <code>sayHello()</code> function does not have any named arguments, leading to a <code>length</code> property value of 0.

            br
            br

            p The <code>prototype</code> property is a crucial aspect of the ECMAScript core. It serves as the actual storage location for all instance methods of reference types. This means that methods like <code>toString()</code> and <code>valueOf()</code> are stored on the <code>prototype</code> and accessed from object instances. The <code>prototype</code> property plays a significant role in defining custom reference types and implementing inheritance. In ECMAScript 5, the <code>prototype</code> property is non-enumerable, which means it won't be discovered using a <code>for-in</code> loop.

            br
            br
            
            h3(id='method_apply') apply()
            p In JavaScript, functions have two useful methods: <code>apply()</code> and <code>call()</code>. These methods allow you to call a function while specifying a particular <code>this</code> value, essentially setting the context within the function.

            p The <code>apply()</code> method takes two arguments: the value of this inside the function and an array of arguments. The second argument can be an array or the <code>arguments</code> object itself. Consider the following:

            pre(class="bg-light")
                code.
                    function multiply(num1, num2) {
                        return num1 * num2;
                    }

                    function callMultiply1(num1, num2) {
                        return multiply.apply(this, arguments);
                    }

                    function callMultiply2(num1, num2) {
                        return multiply.apply(this, [num1, num2]);
                    }

                    console.log(callMultiply1(5, 5)); // Output: 25
                    console.log(callMultiply2(5, 5)); // Output: 25


            p In this example, <code>callMultiply1()</code> call the <code>multiply()</code> function, passing in <code>this</code> as the <code>this</code> value (which is equal to <code>window</code> because it’s being called in the global scope) and also passing in the <code>arguments</code> object. The <code>callMultiply2()</code> method also calls <code>multiply()</code>, but it passes in an array of the arguments instead. Both functions will execute and return the correct result.

            br
            br
            
            h3(id='method_call') call()
            p The <code>call()</code> method functions similarly to <code>apply()</code>, but the way arguments are passed differs. In <code>call()</code>, the first argument is the <code>this</code> value, while the subsequent arguments are passed directly into the function. When using <code>call()</code>, arguments need to be explicitly listed, as shown in this example:

            pre(class="bg-light")
                code.
                    function multiply(num1, num2) {
                        return num1 * num2;
                    }

                    function callMultiply(num1, num2) {
                        return multiply.call(this, num1, num2);
                    }

                    console.log(callMultiply(5, 5)); // Output: 25

            p The <code>callMultiply()</code> method needs to explicitly list each of its arguments when using the <code>call()</code> method. The result is equivalent to using <code>apply()</code>. The choice between <code>apply()</code> and <code>call()</code> depends on the most convenient way for passing arguments into the function. If you plan to pass the <code>arguments</code> object directly or already have an array of data to pass in, then <code>apply()</code> is the preferred option. Otherwise, <code>call()</code> might be more suitable. If there are no arguments to pass in, these methods behave identically.

            br
            br
            
            p The real strength of <code>apply()</code> and <code>call()</code> lies in their capability to modify the <code>this</code> value within the function. Let's explore this concept with the following example:

            pre(class="bg-light")
                code.
                    window.brand = 'Toyota';

                    let car = {
                        brand: 'Ford'
                    };

                    function displayBrand() {
                        console.log(this.brand);
                    }

                    displayBrand(); // 'Toyota'

                    displayBrand.call(this); // 'Toyota'
                    displayBrand.call(window); // 'Toyota'
                    displayBrand.call(car);  // 'Ford'

            p In this example <code>displayBrand()</code> is defined as a global function, and when it’s called in the global scope, it displays "<code>Toyota</code>" because <code>this.brand</code> evaluates to <code>window.brand</code>. You can then call the function explicitly in the global scope by using <code>displayBrand.call(this)</code> and <code>displayBrand.call(window)</code>, which both display "<code>Toyota</code>". Running <code>displayBrand.call(car)</code> switches the context of the function such that <code>this</code> points to <code>car</code>, resulting in a display of "<code>Ford</code>".

            br
            br
            
            h3(id='method_bind') bind()
            p ECMAScript 5 introduces a new method called <code>bind()</code>. The <code>bind()</code> method generates a new function instance where the <code>this</code> value is bound to the value provided to <code>bind()</code>. Here is an example:

            pre(class="bg-light")
                code.
                    window.brand = 'Toyota';

                    let car = {
                        brand: 'Ford'
                    };

                    function displayBrand() {
                        console.log(this.brand);
                    }

                    let boundDisplayBrand = displayBrand.bind(car);
                    boundDisplayBrand(); // 'Ford'

            p Here, a new function called <code>boundDisplayBrand()</code> is created from <code>displayBrand()</code> by calling <code>bind()</code> and passing in the object <code>car</code>. The <code>boundDisplayBrand()</code> function has a <code>this</code> value equivalent to <code>car</code>, so calling the function, even as a global call, results in the string "<code>Ford</code>" being displayed.

            br
            br
            
            h2(id='function_expressions') Function expressions
            p One of the more powerful, and often confusing, parts of JavaScript is <i>function expressions</i>. There are two primary ways to define a function: through <i>function declaration</i> and <i>function expression</i>. Function declaration takes the form:

            pre(class="bg-light")
                code.
                    function functionName(arg0, arg1, arg2) {
                        // function body
                    }

            p One of the key characteristics of function declarations is <b><i>function declaration hoisting</i></b>, a behavior where function declarations are read before the code executes. This allows a function declaration to be placed after the code that calls it and still function correctly:

            pre(class="bg-light")
                code.
                    sayHello();
                    function sayHello() {
                        console.log("Hello!");
                    }

            p This example doesn’t throw an error because of <i>function declaration hoisting</i>. The function declaration is processed first before the code execution begins, allowing the function to be called successfully even though it appears after the call in the code.

            br
            br
            
            p Another method to create a function in JavaScript is through a <i>function expression</i>. Function expressions come in various forms, with the most common being:
            
            pre(class="bg-light")
                code.
                    let functionName = function(arg0, arg1, arg2) {
                        // function body
                    };

            p This pattern of function expression looks like a normal variable assignment. A function is created and assigned to the variable <code>functionName</code>. The created function is considered to be an <i>anonymous function</i>, because it has no identifier after the <code>function</code> keyword. (Anonymous functions are also sometimes called <i>lambda functions</i>.) This means the <code>name</code> property is the empty string.

            p Function expressions behave like other expressions in JavaScript and must be assigned before they are used:
            
            pre(class="bg-light")
                code.
                    sayHello(); // Error! function doesn't exist yet
                    function sayHello() {
                        console.log("Hello!");
                    }
            br
            br
            
            p Understanding <i>function hoisting</i> is key to understanding the differences between function declarations and function expressions. For instance, the result of the following code may be surprising:

            pre(class="bg-light")
                code.
                    // Never do this!
                    if (condition) {
                        function greet() {
                            greeting = 'Hello!';
                        }
                    } else {
                        function greet() {
                            greeting = 'Hi!';
                        }
                    }

            p The code appears to suggest using one definition for <code>greet()</code> if a <code>condition</code> is <code>true</code>, and another definition if <code>false</code>. However, this is not valid syntax in ECMAScript. JavaScript engines attempt to error-correct, but browsers may not consistently handle this situation. Most browsers return the second declaration regardless of the condition, while Firefox returns the first if the condition is <code>true</code>. This approach is unreliable and should be avoided. Instead, it is acceptable to use <i>function expressions</i> in a conditional manner:
            pre(class="bg-light")
                code.
                    // OK
                    let greet;
                    if (condition) {
                        greet = function() {
                            console.log("Hello!");
                        };
                    } else {
                        greet = function() {
                            console.log("Hi!");
                        };
                    }

            p This example behaves the way you would expect, assigning the correct function expression to the variable <code>greet</code> based on condition.

            br
            br
            
            p The ability to create functions for assignment to variables also allows you to return functions as the value of other functions:

            pre(class="bg-light")
                code.
                    function createSortingFunction(property) {
                        return function(obj1, obj2) {
                            let value1 = obj1[property];
                            let value2 = obj2[property];
                            if (value1 < value2) {
                                return -1;
                            } else if (value1 > value2) {
                                return 1;
                            } else {
                                return 0;
                            }
                        };
                    }

            p <code>createSortingFunction()</code> returns an anonymous function. The returned function will, presumably, be either assigned to a variable or otherwise called, but within <code>createSortingFunction()</code> it is anonymous. Any time a function is being used as a value, it is a <i>function expression</i>.

            br
            br
            
        </div>

        <div class="col-sm-4">

            include see_also.pug
            
        </div>
    </div>
